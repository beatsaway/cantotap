<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dottie BPM Synth</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { width: 100vw; height: 100vh; overflow: hidden; font-family: Arial, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #fff; }
        .header { position: fixed; top: 0; left: 0; right: 0; height: 50px; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; gap: 8px; padding: 0 8px; z-index: 1000; border-bottom: 1px solid rgba(255, 255, 255, 0.1); flex-wrap: wrap; }
        .bpm-control { display: flex; align-items: center; gap: 5px; font-size: 12px; }
        .bpm-label { font-size: 11px; font-weight: bold; min-width: 35px; }
        .bpm-toggle { position: relative; width: 40px; height: 20px; background: #333; border-radius: 10px; cursor: pointer; transition: background 0.3s; flex-shrink: 0; }
        .bpm-toggle.active { background: #4CAF50; }
        .bpm-toggle::after { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.3s; }
        .bpm-toggle.active::after { transform: translateX(20px); }
        .bpm-slider-container { display: flex; align-items: center; gap: 5px; }
        .bpm-slider { width: 100px; height: 4px; background: #333; border-radius: 2px; outline: none; -webkit-appearance: none; appearance: none; }
        .bpm-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
        .bpm-slider::-moz-range-thumb { width: 14px; height: 14px; background: #4CAF50; border-radius: 50%; cursor: pointer; border: none; }
        .bpm-value { font-size: 11px; font-weight: bold; min-width: 30px; text-align: center; }
        .volume-cycle-select { padding: 4px 6px; font-size: 11px; background: #333; color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 3px; cursor: pointer; }
        .chord-edit-button { padding: 6px 12px; font-size: 11px; border: 2px solid #4ecdc4; border-radius: 6px; background: rgba(78, 205, 196, 0.2); color: #4ecdc4; cursor: pointer; transition: all 0.2s; font-weight: 600; }
        .canvas { width: 100vw; height: 100vh; position: relative; padding-top: 50px; padding-bottom: 60vh; cursor: crosshair; }
        .bottom-panels { position: fixed; bottom: 0; left: 0; width: 100vw; height: 30vh; display: flex; z-index: 1000; }
        .top-panels { position: fixed; bottom: 30vh; left: 0; width: 100vw; height: 30vh; display: flex; z-index: 1000; }
        .bottom-panel, .top-panel { width: calc(100vw / 4); height: 30vh; box-sizing: border-box; }
        .bottom-panel:nth-child(1) { background: #2a4a6a; } /* Panel 0: Water sound - Blue */
        .bottom-panel:nth-child(2) { background: #3a5a7a; } /* Panel 1: Bell sound - Light Blue */
        .bottom-panel:nth-child(3) { background: #4a6a8a; } /* Panel 2: Pad sound - Lighter Blue */
        .bottom-panel:nth-child(4) { background: #5a7a9a; } /* Panel 3: Lead sound - Lightest Blue */
        .top-panel:nth-child(1) { background: #4a2a6a; } /* Top Panel 0 - Purple */
        .top-panel:nth-child(2) { background: #5a3a7a; } /* Top Panel 1 - Light Purple */
        .top-panel:nth-child(3) { background: #6a4a8a; } /* Top Panel 2 - Lighter Purple */
        .top-panel:nth-child(4) { background: #7a5a9a; } /* Top Panel 3 - Lightest Purple */
        .dottie { position: absolute; width: 50px; height: 50px; border-radius: 50%; cursor: move; user-select: none; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 255, 255, 0.3); display: flex; align-items: center; justify-content: center; z-index: 1001; }
        .dottie-label { font-size: 10px; font-weight: bold; color: rgba(255, 255, 255, 0.9); text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8); pointer-events: none; }
        .dottie.dragging { cursor: grabbing; z-index: 1002; }
        .dottie-0 { background: #ff6b6b; }
        .dottie-1 { background: #4ecdc4; }
        .dottie-2 { background: #ffe66d; }
        .dottie-3 { background: #a8e6cf; }
        .dottie-4 { background: #ff8b94; }
        .dottie-5 { background: #c7ceea; }
        .dottie-6 { background: #ff6b6b; }
        .dottie-7 { background: #4ecdc4; }
        .dottie-8 { background: #ffe66d; }
        .dottie-9 { background: #a8e6cf; }
        .dottie-10 { background: #ff8b94; }
        .dottie-11 { background: #c7ceea; }
        
        /* Chord Editing Interface */
        #chord-editing {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            padding: 100px 30px 30px;
            color: white;
            overflow-y: auto;
        }
        
        #chord-editing.hidden {
            display: none;
        }
        
        .editing-header {
            margin-bottom: 20px;
        }
        
        .editing-header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        #chordInput {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            resize: vertical;
            font-family: monospace;
        }
        
        #chordsDisplay {
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            min-height: 60px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        
        .chord-item {
            padding: 8px 12px;
            background: rgba(78, 205, 196, 0.2);
            border: 1px solid #4ecdc4;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .chord-item.current {
            background: rgba(249, 202, 36, 0.4);
            border-color: #f9ca24;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .chord-edit-button {
            padding: 6px 12px;
            font-size: 11px;
            border: 2px solid #4ecdc4;
            border-radius: 6px;
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }
        
        /* Mobile optimizations */
        @media (max-width: 480px) {
            .header {
                height: 45px;
                gap: 4px;
                padding: 0 4px;
            }
            .bpm-control {
                gap: 3px;
                font-size: 10px;
            }
            .bpm-label {
                font-size: 10px;
                min-width: 30px;
            }
            .bpm-slider {
                width: 80px;
            }
            .bpm-value {
                font-size: 10px;
                min-width: 25px;
            }
            .volume-cycle-select {
                padding: 3px 4px;
                font-size: 10px;
            }
            .chord-edit-button {
                padding: 4px 8px;
                font-size: 10px;
            }
            .canvas {
                padding-top: 45px;
            }
        }
        
        .chord-edit-button:hover {
            background: rgba(78, 205, 196, 0.4);
            transform: scale(1.05);
        }
        
        .top-panel {
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .top-panel:hover {
            opacity: 0.8;
        }
        
        .panel-label {
            font-size: 14px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .panel-chord-name {
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="bpm-control">
            <span class="bpm-label">BPM:</span>
            <div class="bpm-toggle" id="bpmToggle"></div>
            <div class="bpm-slider-container">
                <input type="range" class="bpm-slider" id="bpmSlider" min="60" max="180" value="120">
                <span class="bpm-value" id="bpmValue">120</span>
            </div>
        </div>
        <div class="bpm-control">
            <span class="bpm-label">Volume Cycle:</span>
            <select class="volume-cycle-select" id="volumeCycleSelect">
                <option value="none">None</option>
                <option value="ascend">Ascend</option>
                <option value="descend">Descend</option>
                <option value="triangle">Triangle</option>
            </select>
        </div>
        <button class="chord-edit-button" id="chordEditToggle" style="margin-left: 20px;">Edit Chords</button>
    </div>
    
    <!-- Chord Editing Interface -->
    <div id="chord-editing" class="hidden">
        <div class="editing-header">
            <h1>Chord Sequence Editor</h1>
            <p>Enter chords separated by commas (e.g., C, Dm, E7, Fmaj7, G, Am, Bdim)</p>
        </div>
        <textarea id="chordInput" placeholder="C, Dm, E7, Fmaj7, G, Am, Bdim"></textarea>
        <div id="chordsDisplay"></div>
        <div class="button-group">
            <button class="chord-edit-button" id="closeChordEdit">Close</button>
        </div>
    </div>
    <div class="canvas" id="canvas"></div>
    <div class="top-panels">
        <div class="top-panel" id="topPanel0">
            <div class="panel-label">Previous</div>
            <div class="panel-chord-name" id="panelChord0">-</div>
        </div>
        <div class="top-panel" id="topPanel1">
            <div class="panel-label">Current</div>
            <div class="panel-chord-name" id="panelChord1">-</div>
        </div>
        <div class="top-panel" id="topPanel2">
            <div class="panel-label">Current</div>
            <div class="panel-chord-name" id="panelChord2">-</div>
        </div>
        <div class="top-panel" id="topPanel3">
            <div class="panel-label">Next</div>
            <div class="panel-chord-name" id="panelChord3">-</div>
        </div>
    </div>
    <div class="bottom-panels">
        <div class="bottom-panel"></div>
        <div class="bottom-panel"></div>
        <div class="bottom-panel"></div>
        <div class="bottom-panel"></div>
    </div>
    <script>
        class GridBox {
            constructor(index) {
                this.index = index; // 0, 1, 2, 3 for the 4 panels
                this.chordIntervals = [0, 3, 7]; // A minor chord intervals (root, minor third, fifth)
                this.rootNote = 'A3'; // Base note for the chord
            }

            getNotes() {
                // Convert intervals to actual note names
                const semitonesToNote = (root, semitones) => {
                    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const rootNote = root.match(/^([A-G]#?)(\d+)$/);
                    if (!rootNote) return root;
                    const rootName = rootNote[1];
                    const rootOctave = parseInt(rootNote[2]);
                    const rootIndex = notes.indexOf(rootName);
                    const targetIndex = (rootIndex + semitones) % 12;
                    const octaveOffset = Math.floor((rootIndex + semitones) / 12);
                    return notes[targetIndex] + (rootOctave + octaveOffset);
                };

                const allNotes = this.chordIntervals.map(interval => 
                    semitonesToNote(this.rootNote, interval)
                );

                // Panel 0: 1st note + same note an octave lower
                if (this.index === 0) {
                    const firstNote = allNotes[0];
                    const lowerOctave = firstNote.replace(/(\d+)$/, (match, octave) => (parseInt(octave) - 1).toString());
                    return [lowerOctave, firstNote];
                }
                // Panel 1: 2nd note + 3rd note
                else if (this.index === 1) {
                    return [allNotes[1], allNotes[2]];
                }
                // Panel 2: all notes
                else if (this.index === 2) {
                    return allNotes;
                }
                // Panel 3: highest 2 notes
                else if (this.index === 3) {
                    return [allNotes[1], allNotes[2]];
                }
                return allNotes;
            }
        }

        class Dottie {
            constructor(canvas, pulseDivisor, index) {
                this.canvas = canvas;
                this.pulseDivisor = pulseDivisor;
                this.index = index;
                this.element = null;
                this.label = null;
                this.x = 0;
                this.y = 0;
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.pulseInterval = null;
                this.currentBPM = 120;
                this.pulseScale = 1;
                this.pulseAnimation = null;
                
                this.attack = 0.01;
                this.decay = 0.1;
                this.sustain = 0.15; // Reduced from 0.3 - lower sustain level = quieter
                this.release = 0.2;
                this.chordNotes = ['A3', 'C4', 'E4']; // Default, will be updated based on panel
                this.currentPanelIndex = -1; // Track which panel we're on for sound type
                
                // Don't create audio objects until user interaction
                this.limiter = null;
                this.synths = [];
                this.audioInitialized = false;
                
                this.createElement();
                this.setupEventListeners();
            }

            initializeAudio() {
                if (this.audioInitialized) return;
                if (!window.Tone) {
                    console.error('Tone.js not loaded yet');
                    return;
                }
                try {
                    // Ensure Tone context is started before creating audio objects
                    if (Tone.context.state !== 'running') {
                        Tone.start();
                    }
                    this.limiter = new Tone.Limiter(-0.1).toDestination();
                    this.audioInitialized = true;
                    // Initialize synths after limiter is created
                    this.updateSynths(); // Initialize with default notes
                } catch (error) {
                    console.error('Error initializing audio:', error);
                    console.error('Error details:', error.message, error.stack);
                }
            }

            createWaterVoice(note, panelIndex, startTime, duration) {
                // Panel 0: Water sound (from demo3 area 1)
                const freq = Tone.Frequency(note).toFrequency();
                const now = startTime || Tone.now();
                
                // Main oscillator with pitch drop
                const osc = new Tone.Oscillator({ type: 'sine', frequency: freq * 1.02 });
                osc.frequency.exponentialRampTo(freq, 0.08);
                
                // Harmonic oscillators
                const osc2 = new Tone.Oscillator({ type: 'sine', frequency: freq * 2 * 1.02 });
                osc2.frequency.exponentialRampTo(freq * 2, 0.08);
                const osc3 = new Tone.Oscillator({ type: 'sine', frequency: freq * 3 * 1.02 });
                osc3.frequency.exponentialRampTo(freq * 3, 0.08);
                
                // Noise component
                const noise = new Tone.Noise({ type: 'white', volume: -20 });
                
                // Envelopes (sustain levels from demo3.html)
                const env = new Tone.AmplitudeEnvelope({
                    attack: this.attack,
                    decay: this.decay,
                    sustain: 0.35, // From demo3 - main oscillator
                    release: this.release
                });
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: this.attack,
                    decay: this.decay,
                    sustain: 0.25, // From demo3 - harmonic 2
                    release: this.release
                });
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: this.attack,
                    decay: this.decay,
                    sustain: 0.15, // From demo3 - harmonic 3
                    release: this.release
                });
                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,
                    sustain: 0,
                    release: this.release
                });
                
                // Harmonic gains from demo3.html
                const gain2 = new Tone.Gain(0.3); // From demo3 - harmonic 2
                const gain3 = new Tone.Gain(0.2); // From demo3 - harmonic 3
                const noiseGain = new Tone.Gain(0.03); // From demo3 - noise component
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                // Use multiplier like demo3 (0.2-1.0 range), but scale down for overall quieter
                const volumeGain = new Tone.Gain(0.15); // Scaled down from demo3's 0.2-1.0 range
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(gain2);
                gain2.connect(volumeGain);
                osc3.connect(env3);
                env3.connect(gain3);
                gain3.connect(volumeGain);
                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);
                volumeGain.connect(pan);
                pan.connect(this.limiter);
                
                // Start and trigger
                osc.start(now);
                osc2.start(now);
                osc3.start(now);
                noise.start(now);
                noise.stop(now + Math.min(0.15, duration));
                env.triggerAttack(now);
                env2.triggerAttack(now);
                env3.triggerAttack(now);
                noiseEnv.triggerAttack(now);
                
                const releaseTime = now + duration;
                env.triggerRelease(releaseTime);
                env2.triggerRelease(releaseTime);
                env3.triggerRelease(releaseTime);
                noiseEnv.triggerRelease(releaseTime);
                
                const stopTime = releaseTime + this.release;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                osc3.stop(stopTime);
                
                return { osc, osc2, osc3, noise, env, env2, env3, noiseEnv, pan, volumeGain };
            }

            createBellVoice(note, panelIndex, startTime, duration) {
                // Panel 1: Bell/chime sound (from demo3 area 2)
                const freq = Tone.Frequency(note).toFrequency();
                const now = startTime || Tone.now();
                
                const osc = new Tone.Oscillator({ type: 'triangle', frequency: freq });
                const osc2 = new Tone.Oscillator({ type: 'sine', frequency: freq * 2 });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: this.attack,
                    decay: this.decay * 20, // Longer decay for bell
                    sustain: 0.35, // From demo3 - main oscillator
                    release: this.release
                });
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: this.attack,
                    decay: this.decay * 15,
                    sustain: 0.25, // From demo3 - second oscillator
                    release: this.release
                });
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(0.15); // Scaled down from demo3
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.limiter);
                
                // Start and trigger
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                const releaseTime = now + duration;
                env.triggerRelease(releaseTime);
                env2.triggerRelease(releaseTime);
                
                const stopTime = releaseTime + this.release;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                return { osc, osc2, env, env2, pan, volumeGain };
            }

            createPadVoice(note, panelIndex, startTime, duration) {
                // Panel 2: Pad/string sound (from demo3 area 3)
                const freq = Tone.Frequency(note).toFrequency();
                const now = startTime || Tone.now();
                
                const osc = new Tone.Oscillator({ type: 'sawtooth', frequency: freq });
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 2000,
                    Q: 1.0
                });
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampTo(16000, now + Math.min(0.4, duration * 0.8));
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: this.attack * 30, // Longer attack for pad
                    decay: this.decay * 2,
                    sustain: 0.4, // From demo3 - pad sustain
                    release: this.release
                });
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(0.15); // Scaled down from demo3
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.limiter);
                
                // Start and trigger
                osc.start(now);
                env.triggerAttack(now);
                
                const releaseTime = now + duration;
                env.triggerRelease(releaseTime);
                
                const stopTime = releaseTime + this.release;
                osc.stop(stopTime);
                
                return { osc, filter, env, pan, volumeGain };
            }

            createLeadVoice(note, panelIndex, startTime, duration) {
                // Panel 3: Brass/synth lead (from demo3 area 4)
                const freq = Tone.Frequency(note).toFrequency();
                const now = startTime || Tone.now();
                
                const osc = new Tone.Oscillator({ type: 'sawtooth', frequency: freq });
                const osc2 = new Tone.Oscillator({ type: 'square', frequency: freq * 0.5 });
                
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 3000,
                    Q: 1.0
                });
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampTo(12000, now + Math.min(0.1, duration * 0.2));
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: this.attack * 5,
                    decay: this.decay,
                    sustain: 0.4, // From demo3 - main oscillator
                    release: this.release
                });
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: this.attack * 5,
                    decay: this.decay,
                    sustain: 0.3, // From demo3 - second oscillator
                    release: this.release
                });
                
                const osc2Gain = new Tone.Gain(0.4); // From demo3
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                // Lead voice uses 1.5x multiplier in demo3, but we scale down
                const volumeGain = new Tone.Gain(0.15 * 1.5); // 0.225 - scaled from demo3's volumeMultiplier * 1.5
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(osc2Gain);
                osc2Gain.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(this.limiter);
                
                // Start and trigger
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                const releaseTime = now + duration;
                env.triggerRelease(releaseTime);
                env2.triggerRelease(releaseTime);
                
                const stopTime = releaseTime + this.release;
                osc.stop(stopTime);
                osc2.stop(stopTime);
                
                return { osc, osc2, filter, env, env2, osc2Gain, pan, volumeGain };
            }

            updateSynths(notes = null, panelIndex = -1) {
                if (!window.Tone) {
                    return; // Tone.js not loaded yet
                }
                
                // Ensure limiter is created first
                if (!this.audioInitialized || !this.limiter) {
                    this.initializeAudio();
                    if (!this.limiter) {
                        return; // Still not initialized, exit
                    }
                }
                
                // Dispose old synths
                this.synths.forEach(synth => {
                    if (synth.osc) synth.osc.stop().dispose();
                    if (synth.osc2) synth.osc2.stop().dispose();
                    if (synth.osc3) synth.osc3.stop().dispose();
                    if (synth.noise) synth.noise.stop().dispose();
                    if (synth.env) synth.env.dispose();
                    if (synth.env2) synth.env2.dispose();
                    if (synth.env3) synth.env3.dispose();
                    if (synth.noiseEnv) synth.noiseEnv.dispose();
                    if (synth.filter) synth.filter.dispose();
                    if (synth.pan) synth.pan.dispose();
                    if (synth.volumeGain) synth.volumeGain.dispose();
                    if (synth.osc2Gain) synth.osc2Gain.dispose();
                });
                
                // Use provided notes or default
                const notesToUse = notes || this.chordNotes;
                this.chordNotes = notesToUse;
                this.currentPanelIndex = panelIndex;
                
                // Don't create voices here - create them fresh each pulse
                this.synths = [];
            }

            createElement() {
                this.element = document.createElement('div');
                this.element.className = `dottie dottie-${this.index}`;
                this.label = document.createElement('div');
                this.label.className = 'dottie-label';
                this.label.textContent = `${this.pulseDivisor}/bpm`;
                this.element.appendChild(this.label);
                
                // Place dots in a row below the header
                const headerHeight = 50;
                const dotSize = 50;
                const totalDots = 12; // 2 of each type
                const spacing = (window.innerWidth - (dotSize * totalDots)) / (totalDots + 1);
                this.x = spacing + this.index * (dotSize + spacing);
                this.y = headerHeight + 30; // 30px below header
                
                this.updatePosition();
                this.canvas.appendChild(this.element);
            }

            updatePosition() {
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
            }

            setupEventListeners() {
                this.element.addEventListener('mousedown', (e) => this.startDrag(e));
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('mouseup', () => this.endDrag());
                // Use { passive: false } to allow preventDefault() and silence warnings
                this.element.addEventListener('touchstart', (e) => { e.preventDefault(); this.startDrag(e.touches[0]); }, { passive: false });
                document.addEventListener('touchmove', (e) => { if (this.isDragging) { e.preventDefault(); this.drag(e.touches[0]); } }, { passive: false });
                document.addEventListener('touchend', () => this.endDrag());
            }

            startDrag(e) {
                this.isDragging = true;
                this.element.classList.add('dragging');
                const rect = this.element.getBoundingClientRect();
                // Calculate offset from click point to bottom-right corner
                this.dragOffset.x = e.clientX - (rect.left + rect.width);
                this.dragOffset.y = e.clientY - (rect.top + rect.height);
            }

            drag(e) {
                if (!this.isDragging) return;
                // Position element so bottom-right corner follows the cursor
                const dotWidth = 50;
                const dotHeight = 50;
                this.x = e.clientX - this.dragOffset.x - dotWidth;
                this.y = e.clientY - this.dragOffset.y - dotHeight;
                this.x = Math.max(25, Math.min(window.innerWidth - 25, this.x));
                this.y = Math.max(100, Math.min(window.innerHeight - 25, this.y));
                this.updatePosition();
            }

            endDrag() {
                this.isDragging = false;
                this.element.classList.remove('dragging');
            }

            getPanelIndex() {
                // Panel height is 30vh, convert to pixels
                const panelHeightPx = window.innerHeight * 0.3; // 30vh
                const bottomPanelTop = window.innerHeight - panelHeightPx;
                const dotBottom = this.y + 50; // dot height is 50px
                
                // Only check bottom panels (panels 0-3) for now - top panels are for future use
                if (dotBottom >= bottomPanelTop) {
                    const panelWidth = window.innerWidth / 4;
                    const panelIndex = Math.floor(this.x / panelWidth);
                    return Math.max(0, Math.min(3, panelIndex));
                }
                
                return -1; // Not on any panel
            }

            calculateSoundDuration() {
                // Calculate pulse cycle duration
                const pulseCycleMs = (this.pulseDivisor / this.currentBPM) * 1000;
                
                // Get panel info for y position calculation
                const panelHeightPx = window.innerHeight * 0.3; // 30vh
                const panelTop = window.innerHeight - panelHeightPx;
                const dotCenterY = this.y + 25; // center of dot (50px / 2)
                
                // Normalize y position within panel (0 = top of panel, 1 = bottom of panel)
                // Lower y position (closer to bottom) = higher normalized value = longer duration
                const normalizedY = Math.max(0, Math.min(1, (dotCenterY - panelTop) / panelHeightPx));
                
                // Calculate available duration (leave 10% buffer before next pulse)
                const maxDuration = pulseCycleMs * 0.9;
                const minDuration = Math.min(50, pulseCycleMs * 0.2); // Minimum 50ms or 20% of cycle, whichever is smaller
                
                // Map normalized y position to duration (lower y = longer duration)
                const duration = minDuration + (maxDuration - minDuration) * normalizedY;
                
                return Math.max(minDuration, Math.min(maxDuration, duration));
            }

            pulse() {
                // Calculate interval: pulseDivisor/bpm seconds
                const intervalMs = (this.pulseDivisor / this.currentBPM) * 1000;
                const duration = Math.min(300, Math.max(16, intervalMs * 0.8));
                
                // JavaScript-based pulse animation
                const startTime = performance.now();
                const startScale = this.pulseScale;
                const targetScale = 1.5;
                const color = getComputedStyle(this.element).backgroundColor;
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    if (progress < 0.5) {
                        this.pulseScale = startScale + (targetScale - startScale) * (easeOut * 2);
                    } else {
                        this.pulseScale = targetScale - (targetScale - startScale) * ((easeOut - 0.5) * 2);
                    }
                    
                    this.element.style.transform = `scale(${this.pulseScale})`;
                    const shadowIntensity = progress < 0.5 ? progress * 2 : (1 - progress) * 2;
                    this.element.style.boxShadow = `0 0 ${30 * shadowIntensity}px ${color}`;
                    
                    if (progress < 1) {
                        this.pulseAnimation = requestAnimationFrame(animate);
                    } else {
                        this.pulseScale = 1;
                        this.element.style.transform = 'scale(1)';
                        this.element.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.3)';
                        this.pulseAnimation = null;
                    }
                };
                
                if (this.pulseAnimation) cancelAnimationFrame(this.pulseAnimation);
                this.pulseAnimation = requestAnimationFrame(animate);

                // Only play sound if dot is on white panel
                const panelIndex = this.getPanelIndex();
                if (panelIndex >= 0 && window.Tone) {
                    try {
                        // Ensure audio is initialized
                        if (!this.audioInitialized) {
                            this.initializeAudio();
                        }
                        
                        // Update synths based on current panel if needed
                        if (window.gridBoxes && window.gridBoxes[panelIndex]) {
                            const panelNotes = window.gridBoxes[panelIndex].getNotes();
                            // Update if notes changed or panel changed
                            if (JSON.stringify(panelNotes) !== JSON.stringify(this.chordNotes) || 
                                this.currentPanelIndex !== panelIndex) {
                                this.updateSynths(panelNotes, panelIndex);
                            }
                        }
                        
                        // Calculate sound duration based on pulse rate and y position
                        const soundDuration = this.calculateSoundDuration();
                        
                        // Create and trigger voices based on panel type
                        const now = Tone.now();
                        const durationSec = soundDuration / 1000;
                        
                        // Clean up old voices
                        this.synths.forEach(voice => {
                            try {
                                if (voice.osc) voice.osc.stop().dispose();
                                if (voice.osc2) voice.osc2.stop().dispose();
                                if (voice.osc3) voice.osc3.stop().dispose();
                                if (voice.noise) voice.noise.stop().dispose();
                                if (voice.env) voice.env.dispose();
                                if (voice.env2) voice.env2.dispose();
                                if (voice.env3) voice.env3.dispose();
                                if (voice.noiseEnv) voice.noiseEnv.dispose();
                                if (voice.filter) voice.filter.dispose();
                                if (voice.pan) voice.pan.dispose();
                                if (voice.volumeGain) voice.volumeGain.dispose();
                                if (voice.osc2Gain) voice.osc2Gain.dispose();
                            } catch (e) {}
                        });
                        
                        // Create fresh voices for this pulse
                        this.synths = this.chordNotes.map(note => {
                            if (panelIndex === 0) {
                                return this.createWaterVoice(note, panelIndex, now, durationSec);
                            } else if (panelIndex === 1) {
                                return this.createBellVoice(note, panelIndex, now, durationSec);
                            } else if (panelIndex === 2) {
                                return this.createPadVoice(note, panelIndex, now, durationSec);
                            } else if (panelIndex === 3) {
                                return this.createLeadVoice(note, panelIndex, now, durationSec);
                            } else {
                                // Default: simple sine synth
                                const synth = new Tone.PolySynth(Tone.Synth, {
                                oscillator: { type: 'sine' },
                                envelope: { attack: this.attack, decay: this.decay, sustain: this.sustain, release: this.release },
                                volume: -30
                                });
                                synth.connect(this.limiter);
                                synth.triggerAttackRelease(note, durationSec);
                                return synth;
                            }
                        });
                    } catch (error) {
                        console.error('Error playing sound:', error);
                    }
                }
            }

            start(bpm, masterStartTime) {
                this.stop();
                if (!bpm || bpm <= 0) return;
                this.currentBPM = bpm;
                this.masterStartTime = masterStartTime || performance.now();
                // pulseDivisor/bpm means: pulse every (pulseDivisor/bpm) seconds
                // Example: 240/120 = 2 seconds between pulses
                this.intervalMs = (this.pulseDivisor / bpm) * 1000;
                
                // Sync to master timer - calculate when next pulse should occur
                const elapsed = performance.now() - this.masterStartTime;
                const cyclesSinceStart = Math.floor(elapsed / this.intervalMs);
                this.lastPulseTime = this.masterStartTime + (cyclesSinceStart * this.intervalMs);
                
                // Start animation loop that syncs to master
                const animate = (currentTime) => {
                    if (currentTime - this.lastPulseTime >= this.intervalMs) {
                        this.pulse();
                        this.lastPulseTime += this.intervalMs; // Keep in sync with master
                    }
                    // Continue animation loop if still active
                    if (this.pulseInterval) {
                        this.animationFrame = requestAnimationFrame(animate);
                    }
                };
                // Set pulseInterval before starting animation
                this.pulseInterval = true;
                this.animationFrame = requestAnimationFrame(animate);
            }

            stop() {
                if (this.pulseInterval) {
                    if (this.animationFrame) cancelAnimationFrame(this.animationFrame);
                    this.pulseInterval = null;
                    this.animationFrame = null;
                }
                if (this.pulseAnimation) {
                    cancelAnimationFrame(this.pulseAnimation);
                    this.pulseAnimation = null;
                }
                this.pulseScale = 1;
                this.element.style.transform = 'scale(1)';
                this.element.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.3)';
            }

            updateBPM(bpm, masterStartTime) {
                if (this.pulseInterval) {
                    this.start(bpm, masterStartTime);
                }
            }

            destroy() {
                this.stop();
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                if (this.audioInitialized) {
                    this.synths.forEach(synth => synth.dispose());
                    if (this.limiter) this.limiter.dispose();
                }
            }
        }

        // ========== CHORD PARSER ==========
        const ChordParser = {
            NOTE_TO_INDEX: {
                'C': 0, 'C#': 1, 'Db': 1,
                'D': 2, 'D#': 3, 'Eb': 3,
                'E': 4,
                'F': 5, 'F#': 6, 'Gb': 6,
                'G': 7, 'G#': 8, 'Ab': 8,
                'A': 9, 'A#': 10, 'Bb': 10,
                'B': 11
            },
            
            CHORD_INTERVALS: {
                'major-triad': [0, 4, 7],
                'minor-triad': [0, 3, 7],
                'dominant-7th': [0, 4, 7, 10],
                'minor-7th': [0, 3, 7, 10],
                'major-7th': [0, 4, 7, 11],
                'diminished-triad': [0, 3, 6],
                'diminished-7th': [0, 3, 6, 9],
                'augmented-triad': [0, 4, 8],
                'major-6th': [0, 4, 7, 9],
                'minor-6th': [0, 3, 7, 9],
                'dominant-9th': [0, 4, 7, 10, 14],
                'major-9th': [0, 4, 7, 11, 14],
                'minor-9th': [0, 3, 7, 10, 14],
                'add9': [0, 4, 7, 14],
                'add11': [0, 4, 7, 17],
                'add13': [0, 4, 7, 21],
                '7sharp11': [0, 4, 7, 10, 18],
                '9sharp11': [0, 4, 7, 10, 14, 18],
                'sus2': [0, 2, 7],
                'sus4': [0, 5, 7]
            },
            
            parseChord(input) {
                const trimmed = input.trim();
                if (!trimmed) return null;

                const match = trimmed.match(/^([A-Ga-g])([#b]?)(.*)$/i);
                if (!match) return null;

                const rootLetter = match[1].toUpperCase();
                const accidental = match[2] || '';
                const suffix = match[3].toLowerCase();
                const noteName = rootLetter + accidental;

                if (!this.NOTE_TO_INDEX.hasOwnProperty(noteName)) return null;

                let chordType = 'major-triad';
                let processedSuffix = suffix;
                
                const slashIndex = suffix.indexOf('/');
                if (slashIndex !== -1) {
                    processedSuffix = suffix.substring(0, slashIndex);
                }

                if (processedSuffix === 'm' || processedSuffix === 'min' || processedSuffix === '-') {
                    chordType = 'minor-triad';
                } else if (processedSuffix === '7' || processedSuffix === 'dom' || processedSuffix === 'dom7') {
                    chordType = 'dominant-7th';
                } else if (processedSuffix === 'm7' || processedSuffix === 'min7') {
                    chordType = 'minor-7th';
                } else if (processedSuffix.includes('dim')) {
                    chordType = processedSuffix.includes('7') ? 'diminished-7th' : 'diminished-triad';
                } else if (processedSuffix.includes('aug') || processedSuffix === '+') {
                    chordType = 'augmented-triad';
                } else if (processedSuffix === 'maj9' || processedSuffix === 'major9' || processedSuffix === 'M9') {
                    chordType = 'major-9th';
                } else if (processedSuffix === 'm9' || processedSuffix === 'min9' || processedSuffix === '-9') {
                    chordType = 'minor-9th';
                } else if (processedSuffix === '9') {
                    chordType = 'dominant-9th';
                } else if (processedSuffix === 'maj7' || processedSuffix === 'major7' || processedSuffix === 'M7' || processedSuffix === 'ma7') {
                    chordType = 'major-7th';
                } else if (processedSuffix === '6') {
                    chordType = 'major-6th';
                } else if (processedSuffix === 'm6' || processedSuffix === 'min6' || processedSuffix === '-6') {
                    chordType = 'minor-6th';
                } else if (processedSuffix.includes('add9')) {
                    chordType = 'add9';
                } else if (processedSuffix.includes('add11')) {
                    chordType = 'add11';
                } else if (processedSuffix.includes('add13')) {
                    chordType = 'add13';
                } else if (processedSuffix.includes('7#11') || processedSuffix.includes('7(#11)') || processedSuffix.includes('7+11')) {
                    chordType = '7sharp11';
                } else if (processedSuffix.includes('9#11') || processedSuffix.includes('9(#11)') || processedSuffix.includes('9+11')) {
                    chordType = '9sharp11';
                } else if (processedSuffix.includes('sus2') || processedSuffix === 'sus2') {
                    chordType = 'sus2';
                } else if (processedSuffix.includes('sus4') || processedSuffix === 'sus' || processedSuffix === 'sus4') {
                    chordType = 'sus4';
                }

                return { rootNote: noteName, chordType };
            },

            parseChords(input) {
                return input.split(',').map(s => s.trim()).filter(s => s)
                    .map(str => this.parseChord(str)).filter(c => c !== null);
            },

            getChordIntervals(rootNote, chordType) {
                const rootIndex = this.NOTE_TO_INDEX[rootNote];
                if (rootIndex === undefined) return [0, 3, 7]; // Default to minor triad

                const intervals = this.CHORD_INTERVALS[chordType];
                if (!intervals) return [0, 3, 7]; // Default to minor triad

                return intervals;
            }
        };

        // ========== CHORD SEQUENCE STATE ==========
        let parsedChords = [];
        let currentChordIndex = 0;

        // ========== CHORD SEQUENCE MANAGEMENT ==========
        function updateChordDisplay() {
            const display = document.getElementById('chordsDisplay');
            display.innerHTML = '';
            
            parsedChords.forEach((chord, index) => {
                const span = document.createElement('span');
                span.className = 'chord-item';
                if (index === currentChordIndex) {
                    span.classList.add('current');
                }
                span.textContent = `${chord.rootNote}${getChordSuffix(chord.chordType)}`;
                display.appendChild(span);
            });
        }

        function getChordSuffix(chordType) {
            const map = {
                'minor-triad': 'm',
                'dominant-7th': '7',
                'minor-7th': 'm7',
                'major-7th': 'maj7',
                'diminished-triad': 'dim',
                'diminished-7th': 'dim7',
                'augmented-triad': 'aug',
                'major-6th': '6',
                'minor-6th': 'm6',
                'major-9th': 'maj9',
                'dominant-9th': '9',
                'minor-9th': 'm9',
                'add9': 'add9',
                'add11': 'add11',
                'add13': 'add13',
                '7sharp11': '7#11',
                '9sharp11': '9#11',
                'sus2': 'sus2',
                'sus4': 'sus4'
            };
            return map[chordType] || '';
        }

        function updateGridBoxesWithCurrentChord() {
            if (parsedChords.length === 0) return;
            
            const currentChord = parsedChords[currentChordIndex];
            const intervals = ChordParser.getChordIntervals(currentChord.rootNote, currentChord.chordType);
            
            // Update all GridBox instances
            if (window.gridBoxes) {
                window.gridBoxes.forEach(gridBox => {
                    gridBox.chordIntervals = intervals;
                    gridBox.rootNote = currentChord.rootNote + '3'; // Use octave 3 as base
                });
            }
        }

        function updatePurplePanelLabels() {
            if (parsedChords.length === 0) {
                // No chords - show dashes
                document.getElementById('panelChord0').textContent = '-';
                document.getElementById('panelChord1').textContent = '-';
                document.getElementById('panelChord2').textContent = '-';
                document.getElementById('panelChord3').textContent = '-';
                return;
            }

            // Previous chord (panel 0)
            const prevIndex = (currentChordIndex - 1 + parsedChords.length) % parsedChords.length;
            const prevChord = parsedChords[prevIndex];
            document.getElementById('panelChord0').textContent = `${prevChord.rootNote}${getChordSuffix(prevChord.chordType)}`;

            // Current chord (panels 1 and 2)
            const currentChord = parsedChords[currentChordIndex];
            const currentChordName = `${currentChord.rootNote}${getChordSuffix(currentChord.chordType)}`;
            document.getElementById('panelChord1').textContent = currentChordName;
            document.getElementById('panelChord2').textContent = currentChordName;

            // Next chord (panel 3)
            const nextIndex = (currentChordIndex + 1) % parsedChords.length;
            const nextChord = parsedChords[nextIndex];
            document.getElementById('panelChord3').textContent = `${nextChord.rootNote}${getChordSuffix(nextChord.chordType)}`;
        }

        // ========== PURPLE PANEL CHORD SOUND ==========
        // Store active synths per panel for sustain/release
        const activePurpleSynths = {};

        function startPurplePanelChord(panelIndex, chord) {
            // Ensure Tone.js is loaded - if not, try to load it
            if (!window.Tone) {
                console.warn('Tone.js not loaded yet, attempting to load...');
                if (window.dottieApp && window.dottieApp.toneJsLoaded) {
                    // Wait a bit for Tone to be available
                    setTimeout(() => startPurplePanelChord(panelIndex, chord), 100);
                }
                return;
            }

            try {
                // Ensure Tone context is started
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }

                // Release any existing sound on this panel
                if (activePurpleSynths[panelIndex]) {
                    releasePurplePanelChord(panelIndex);
                }

                // Get chord intervals and convert to note names
                const intervals = ChordParser.getChordIntervals(chord.rootNote, chord.chordType);
                const baseFreq = {
                    'C': 261.63, 'C#': 277.18, 'Db': 277.18, 'D': 293.66, 'D#': 311.13, 'Eb': 311.13,
                    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'Gb': 369.99, 'G': 392.00,
                    'G#': 415.30, 'Ab': 415.30, 'A': 440.00, 'A#': 466.16, 'Bb': 466.16, 'B': 493.88
                };

                const rootFreq = baseFreq[chord.rootNote] || 440;
                const notes = intervals.map(interval => {
                    const freq = rootFreq * Math.pow(2, interval / 12);
                    return Tone.Frequency(freq).toNote();
                });

                // Use PolySynth with sustain-friendly envelope
                const synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: {
                        type: 'triangle'
                    },
                    envelope: {
                        attack: 0.01,
                        decay: 0.2,
                        sustain: 0.6,  // Higher sustain for hold
                        release: 0.5   // Release time
                    },
                    volume: -8  // Louder for purple panels
                });

                // Create a simple gain node instead of reverb (reverb needs async generation)
                const gain = new Tone.Gain(0.8).toDestination();
                synth.connect(gain);

                // Store synth and gain for this panel
                activePurpleSynths[panelIndex] = {
                    synth: synth,
                    gain: gain,
                    notes: notes
                };

                // Trigger attack (sustain will hold while touch is down)
                synth.triggerAttack(notes);
            } catch (error) {
                console.error('Error starting purple panel chord:', error);
            }
        }

        function releasePurplePanelChord(panelIndex) {
            if (!activePurpleSynths[panelIndex]) return;

            try {
                const { synth, gain, notes } = activePurpleSynths[panelIndex];
                
                // Trigger release
                synth.triggerRelease(notes);
                
                // Clean up after release
                setTimeout(() => {
                    try {
                        synth.dispose();
                        gain.dispose();
                    } catch (e) {
                        // Ignore disposal errors
                    }
                    delete activePurpleSynths[panelIndex];
                }, 600); // Wait for release to complete
            } catch (error) {
                console.error('Error releasing purple panel chord:', error);
                delete activePurpleSynths[panelIndex];
            }
        }

        function navigateToPreviousChord() {
            if (parsedChords.length === 0) return;
            currentChordIndex = (currentChordIndex - 1 + parsedChords.length) % parsedChords.length;
            updateChordDisplay();
            updateGridBoxesWithCurrentChord();
            updatePurplePanelLabels();
        }

        function navigateToNextChord() {
            if (parsedChords.length === 0) return;
            currentChordIndex = (currentChordIndex + 1) % parsedChords.length;
            updateChordDisplay();
            updateGridBoxesWithCurrentChord();
            updatePurplePanelLabels();
        }

        function getChordForPanel(panelIndex) {
            if (parsedChords.length === 0) return null;
            
            if (panelIndex === 0) {
                // Previous chord
                const prevIndex = (currentChordIndex - 1 + parsedChords.length) % parsedChords.length;
                return parsedChords[prevIndex];
            } else if (panelIndex === 3) {
                // Next chord
                const nextIndex = (currentChordIndex + 1) % parsedChords.length;
                return parsedChords[nextIndex];
            } else {
                // Current chord (panels 1 and 2)
                return parsedChords[currentChordIndex];
            }
        }

        // ========== SETUP CHORD EDITING UI ==========
        function setupChordEditing() {
            const toggleBtn = document.getElementById('chordEditToggle');
            const closeBtn = document.getElementById('closeChordEdit');
            const chordEditing = document.getElementById('chord-editing');
            const chordInput = document.getElementById('chordInput');

            toggleBtn.addEventListener('click', () => {
                chordEditing.classList.toggle('hidden');
            });

            closeBtn.addEventListener('click', () => {
                chordEditing.classList.add('hidden');
            });

            chordInput.addEventListener('input', () => {
                const input = chordInput.value;
                parsedChords = ChordParser.parseChords(input);
                if (parsedChords.length > 0) {
                    currentChordIndex = 0;
                    updateChordDisplay();
                    updateGridBoxesWithCurrentChord();
                    updatePurplePanelLabels();
                } else {
                    updateChordDisplay();
                    updatePurplePanelLabels();
                }
            });

            // Setup purple panel touch/mouse handlers for sustain/release
            const topPanels = document.querySelectorAll('.top-panel');
            topPanels.forEach((panel, index) => {
                let isActive = false;
                
                // Touch events
                panel.addEventListener('touchstart', async (e) => {
                    e.preventDefault();
                    if (parsedChords.length === 0) return;
                    
                    // Ensure Tone.js is loaded and audio context is started
                    if (!window.Tone && window.dottieApp) {
                        try {
                            await window.dottieApp.loadToneJS();
                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }
                        } catch (err) {
                            console.error('Failed to load Tone.js:', err);
                            return;
                        }
                    } else if (window.Tone && Tone.context.state !== 'running') {
                        await Tone.start();
                    }
                    
                    isActive = true;
                    
                    // Navigate if needed
                    if (index === 0) {
                        navigateToPreviousChord();
                    } else if (index === 3) {
                        navigateToNextChord();
                    }
                    
                    // Start sound
                    const chord = getChordForPanel(index);
                    if (chord) {
                        startPurplePanelChord(index, chord);
                    }
                }, { passive: false });
                
                panel.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (isActive) {
                        releasePurplePanelChord(index);
                        isActive = false;
                    }
                }, { passive: false });
                
                panel.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    if (isActive) {
                        releasePurplePanelChord(index);
                        isActive = false;
                    }
                }, { passive: false });
                
                // Mouse events (for desktop)
                panel.addEventListener('mousedown', async (e) => {
                    if (parsedChords.length === 0) return;
                    
                    // Ensure Tone.js is loaded and audio context is started
                    if (!window.Tone && window.dottieApp) {
                        try {
                            await window.dottieApp.loadToneJS();
                            if (Tone.context.state !== 'running') {
                                await Tone.start();
                            }
                        } catch (err) {
                            console.error('Failed to load Tone.js:', err);
                            return;
                        }
                    } else if (window.Tone && Tone.context.state !== 'running') {
                        await Tone.start();
                    }
                    
                    isActive = true;
                    
                    // Navigate if needed
                    if (index === 0) {
                        navigateToPreviousChord();
                    } else if (index === 3) {
                        navigateToNextChord();
                    }
                    
                    // Start sound
                    const chord = getChordForPanel(index);
                    if (chord) {
                        startPurplePanelChord(index, chord);
                    }
                });
                
                panel.addEventListener('mouseup', () => {
                    if (isActive) {
                        releasePurplePanelChord(index);
                        isActive = false;
                    }
                });
                
                panel.addEventListener('mouseleave', () => {
                    if (isActive) {
                        releasePurplePanelChord(index);
                        isActive = false;
                    }
                });
            });
        }

        class DottieApp {
            constructor() {
                this.bpm = 120;
                this.isPlaying = false;
                this.dotties = [];
                this.canvas = document.getElementById('canvas');
                this.pulseDivisors = [240, 120, 60, 40, 20, 15];
                this.audioContextStarted = false;
                this.toneJsLoaded = false;
                this.masterStartTime = null; // Universal start time for all dots
                this.volumeCycleMode = 'none'; // 'none', 'ascend', 'descend', 'triangle'
                this.volumeCycleInterval = null; // Interval ID for volume cycling
                this.init();
            }

            loadToneJS() {
                return new Promise((resolve, reject) => {
                    if (window.Tone) {
                        this.toneJsLoaded = true;
                        resolve();
                        return;
                    }
                    if (this.toneJsLoaded) {
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js';
                    script.onload = () => {
                        this.toneJsLoaded = true;
                        resolve();
                    };
                    script.onerror = () => {
                        reject(new Error('Failed to load Tone.js'));
                    };
                    document.head.appendChild(script);
                });
            }

            init() {
                this.setupControls();
                this.createGridBoxes();
                this.createDotties();
                // Don't access Tone objects here - wait for user to toggle BPM on
            }

            createGridBoxes() {
                // Create GridBox instances for the 4 panels
                window.gridBoxes = [];
                for (let i = 0; i < 4; i++) {
                    window.gridBoxes.push(new GridBox(i));
                }
            }

            setupControls() {
                const toggle = document.getElementById('bpmToggle');
                const slider = document.getElementById('bpmSlider');
                const valueDisplay = document.getElementById('bpmValue');

                toggle.addEventListener('click', async () => {
                    this.isPlaying = !this.isPlaying;
                    toggle.classList.toggle('active', this.isPlaying);
                    if (this.isPlaying) {
                        // Load Tone.js and start audio context only on first toggle on
                        if (!this.audioContextStarted) {
                            try {
                                await this.loadToneJS();
                                Tone.start();
                                Tone.getDestination().volume.value = -18;
                                this.audioContextStarted = true;
                            } catch (error) {
                                console.error('Failed to load Tone.js:', error);
                                this.isPlaying = false;
                                toggle.classList.remove('active');
                                return;
                            }
                        }
                        this.start();
                    } else {
                        this.stop();
                    }
                });

                slider.addEventListener('input', (e) => {
                    this.bpm = parseInt(e.target.value);
                    valueDisplay.textContent = this.bpm;
                    if (this.isPlaying) this.updateBPM();
                });

                const volumeCycleSelect = document.getElementById('volumeCycleSelect');
                if (volumeCycleSelect) {
                    volumeCycleSelect.addEventListener('change', (e) => {
                        this.volumeCycleMode = e.target.value;
                        if (this.isPlaying) {
                            this.startVolumeCycle();
                        }
                    });
                }

                toggle.classList.toggle('active', this.isPlaying);
                valueDisplay.textContent = this.bpm;
            }

            createDotties() {
                // Create 2 of each dot type (12 dots total)
                this.pulseDivisors.forEach((divisor, index) => {
                    // First instance
                    const dottie1 = new Dottie(this.canvas, divisor, index);
                    this.dotties.push(dottie1);
                    // Second instance
                    const dottie2 = new Dottie(this.canvas, divisor, index + 6);
                    this.dotties.push(dottie2);
                });
            }

            start() {
                // Set master start time for synchronization
                this.masterStartTime = performance.now();
                
                // Initialize audio for all dotties when starting
                this.dotties.forEach(dottie => {
                    if (window.Tone) {
                        dottie.initializeAudio();
                    }
                    dottie.start(this.bpm, this.masterStartTime);
                });
                
                // Start volume cycling update loop
                this.startVolumeCycle();
            }
            
            startVolumeCycle() {
                if (this.volumeCycleInterval) {
                    clearInterval(this.volumeCycleInterval);
                }
                
                if (this.volumeCycleMode === 'none') {
                    // Reset to base volume
                    if (window.Tone) {
                        Tone.getDestination().volume.value = -18;
                    }
                    return;
                }
                
                // Update master volume based on cycle position
                const updateVolume = () => {
                    if (!window.Tone || !this.masterStartTime) return;
                    
                    // Calculate position in 240/bpm cycle (0 to 1)
                    const cycle240Ms = (240 / this.bpm) * 1000;
                    const timeSinceStart = performance.now() - this.masterStartTime;
                    const cyclePosition = (timeSinceStart % cycle240Ms) / cycle240Ms;
                    
                    let volumeMultiplier = 1.0;
                    if (this.volumeCycleMode === 'ascend') {
                        // Gradually get louder: 0.3 to 1.0
                        volumeMultiplier = 0.3 + (cyclePosition * 0.7);
                    } else if (this.volumeCycleMode === 'descend') {
                        // Gradually get quieter: 1.0 to 0.3
                        volumeMultiplier = 1.0 - (cyclePosition * 0.7);
                    } else if (this.volumeCycleMode === 'triangle') {
                        // Loudest in middle: 0.3 -> 1.0 -> 0.3
                        if (cyclePosition < 0.5) {
                            volumeMultiplier = 0.3 + (cyclePosition * 2 * 0.7);
                        } else {
                            volumeMultiplier = 1.0 - ((cyclePosition - 0.5) * 2 * 0.7);
                        }
                    }
                    
                    // Convert multiplier to dB (base -18dB, range -18 to -6.5dB approximately)
                    // volumeMultiplier 0.3 = -10.5dB, 1.0 = 0dB relative to base
                    const baseVolume = -18;
                    const volumeRange = 11.5; // From -18 to -6.5
                    const targetVolume = baseVolume + (volumeRange * (volumeMultiplier - 0.3) / 0.7);
                    Tone.getDestination().volume.value = targetVolume;
                };
                
                // Update every 16ms (60fps) for smooth transitions
                this.volumeCycleInterval = setInterval(updateVolume, 16);
                updateVolume(); // Initial update
            }

            stop() {
                this.masterStartTime = null;
                this.dotties.forEach(dottie => dottie.stop());
                
                // Stop volume cycling
                if (this.volumeCycleInterval) {
                    clearInterval(this.volumeCycleInterval);
                    this.volumeCycleInterval = null;
                }
                
                // Reset to base volume
                if (window.Tone) {
                    Tone.getDestination().volume.value = -18;
                }
            }

            updateBPM() {
                // Keep the same master start time when updating BPM to maintain sync
                const masterStartTime = this.masterStartTime || performance.now();
                this.dotties.forEach(dottie => dottie.updateBPM(this.bpm, masterStartTime));
            }
        }

        window.addEventListener('load', () => {
            window.dottieApp = new DottieApp();
            setupChordEditing();
            updatePurplePanelLabels(); // Initialize with dashes
        });
    </script>
</body>
</html>
