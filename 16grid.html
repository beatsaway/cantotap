<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Synth Grid Demo 3 - Multi-Touch Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100vw;
            height: 100vh;
            gap: 0;
        }

        .grid-cell {
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.1s;
        }

        .grid-cell:active,
        .grid-cell.active {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .grid-cell.dragging-over {
            border: 2px solid white;
        }

        .grid-cell:nth-child(1) {
            background: linear-gradient(135deg, #2a4a6a, #1a2a3a);
        }

        .grid-cell:nth-child(2) {
            background: linear-gradient(135deg, #3a5a7a, #2a3a4a);
        }

        .grid-cell:nth-child(3) {
            background: linear-gradient(135deg, #4a6a8a, #3a4a5a);
        }

        .grid-cell:nth-child(4) {
            background: linear-gradient(135deg, #5a7a9a, #4a5a6a);
        }

        .grid-cell:nth-child(5) {
            background: linear-gradient(135deg, #6a8aaa, #5a6a7a);
        }

        .grid-cell:nth-child(6) {
            background: linear-gradient(135deg, #7a9aba, #6a7a8a);
        }

        .grid-cell:nth-child(7) {
            background: linear-gradient(135deg, #8aaaca, #7a8a9a);
        }

        .grid-cell:nth-child(8) {
            background: linear-gradient(135deg, #9abada, #8a9aaa);
        }

        .grid-cell:nth-child(9) {
            background: linear-gradient(135deg, #aacaea, #9aba9a);
        }

        .grid-cell:nth-child(10) {
            background: linear-gradient(135deg, #badafa, #aacaba);
        }

        .grid-cell:nth-child(11) {
            background: linear-gradient(135deg, #caeafa, #badaca);
        }

        .grid-cell:nth-child(12) {
            background: linear-gradient(135deg, #dafa0a, #ca0ada);
        }

        .grid-cell:nth-child(13) {
            background: linear-gradient(135deg, #ea0a1a, #da0a0a);
        }

        .grid-cell:nth-child(14) {
            background: linear-gradient(135deg, #fa1a2a, #ea1a1a);
        }

        .grid-cell:nth-child(15) {
            background: linear-gradient(135deg, #0a2a3a, #1a2a3a);
        }

        .grid-cell:nth-child(16) {
            background: linear-gradient(135deg, #1a3a4a, #2a3a4a);
        }

        /* Touch dot visualization */
        .touch-dot {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            pointer-events: none !important;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: opacity 2s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            will-change: transform;
            opacity: 1;
        }

        /* Debug info for each dot */
        .dot-debug-info {
            position: fixed;
            font-size: 0.65rem;
            font-weight: normal;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 6px;
            border-radius: 4px;
            font-family: monospace;
            line-height: 1.2;
            pointer-events: none !important;
            z-index: 1001;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: pre;
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 150px;
        }
    </style>
</head>
<body>
    <div class="grid-container">
        <div class="grid-cell" data-cell="1">Area 1<br>Chord</div>
        <div class="grid-cell" data-cell="2">Area 2</div>
        <div class="grid-cell" data-cell="3">Area 3</div>
        <div class="grid-cell" data-cell="4">Area 4</div>
        <div class="grid-cell" data-cell="5">Area 5</div>
        <div class="grid-cell" data-cell="6">Area 6</div>
        <div class="grid-cell" data-cell="7">Area 7</div>
        <div class="grid-cell" data-cell="8">Area 8</div>
        <div class="grid-cell" data-cell="9">Area 9</div>
        <div class="grid-cell" data-cell="10">Area 10</div>
        <div class="grid-cell" data-cell="11">Area 11</div>
        <div class="grid-cell" data-cell="12">Area 12</div>
        <div class="grid-cell" data-cell="13">Area 13</div>
        <div class="grid-cell" data-cell="14">Area 14</div>
        <div class="grid-cell" data-cell="15">Area 15</div>
        <div class="grid-cell" data-cell="16">Area 16</div>
    </div>

    <script>
       
        class WaterSynthTone {
            constructor() {
                // Create reverb with very wet signal (like original: 1.0 reverb, 0.3 dry)
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 0.77  // Very wet reverb (1.0 / (1.0 + 0.3))
                }).toDestination();

                // Create compressor/limiter
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                }).connect(this.reverb);

                // Create EQ for natural rolloff (for area 2/bell sounds)
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                }).connect(this.compressor);

                // Master gain - split into dry and wet paths
                this.masterGain = new Tone.Gain(1.0);
                this.dryGain = new Tone.Gain(0.3).connect(this.eq);  // Less dry signal (for bell/area 2)
                this.reverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Very loud reverb
                
                // Separate path for area 1 (water sounds) - bypasses filter
                this.area1DryGain = new Tone.Gain(0.3).connect(this.compressor);  // Direct to compressor, no filter
                this.area1ReverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Reverb path
                
                // Connect master to both paths (for bell/area 2)
                this.masterGain.connect(this.dryGain);
                this.masterGain.connect(this.reverbGain);
                
                // Separate master gain for area 1 (no filter)
                this.masterGainArea1 = new Tone.Gain(1.0);
                this.masterGainArea1.connect(this.area1DryGain);
                this.masterGainArea1.connect(this.area1ReverbGain);

                // Generate reverb impulse response
                this.reverb.generate().catch(console.error);
            }

            // Create a water-like sound with pitch drop and noise
            createWaterVoice(frequency, pitchDrop = 0.02, noiseAmount = 0.03, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Add natural variation (like original)
                const finalPitchDrop = frequency * (pitchDrop + Math.random() * 0.02);
                const finalNoiseAmount = noiseAmount * (0.8 + Math.random() * 0.4);

                // Apply pitch offset (in semitones, converted to frequency ratio)
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;

                // Main oscillator with pitch drop on attack
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency + finalPitchDrop
                });

                // Frequency envelope for pitch drop - exponential ramp
                osc.frequency.exponentialRampTo(adjustedFrequency, 0.08);

                // Add harmonic oscillators
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 2) + (finalPitchDrop * 2)
                });
                osc2.frequency.exponentialRampTo(adjustedFrequency * 2, 0.08);
                
                const osc3 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 3) + (finalPitchDrop * 3)
                });
                osc3.frequency.exponentialRampTo(adjustedFrequency * 3, 0.08);
                
                const osc4 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 4) + (finalPitchDrop * 4)
                });
                osc4.frequency.exponentialRampTo(adjustedFrequency * 4, 0.08);

                // Amplitude envelopes
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.35,
                    release: 0.3
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.25,
                    release: 0.3
                });
                
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.15,
                    release: 0.3
                });
                
                const env4 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.1,
                    release: 0.3
                });
                
                const harmonicGain2 = new Tone.Gain(0.3);
                const harmonicGain3 = new Tone.Gain(0.2);
                const harmonicGain4 = new Tone.Gain(0.1);

                // Noise component
                const noise = new Tone.Noise({
                    type: 'white',
                    volume: -20
                });

                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,
                    sustain: 0,
                    release: 0
                });

                const noiseGain = new Tone.Gain();
                noiseGain.gain.value = finalNoiseAmount * 0.5;

                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);

                // Connect oscillators
                osc.connect(env);
                env.connect(volumeGain);
                
                osc2.connect(env2);
                env2.connect(harmonicGain2);
                harmonicGain2.connect(volumeGain);
                
                osc3.connect(env3);
                env3.connect(harmonicGain3);
                harmonicGain3.connect(volumeGain);
                
                osc4.connect(env4);
                env4.connect(harmonicGain4);
                harmonicGain4.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGainArea1);

                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);

                // Start
                osc.start(now);
                osc2.start(now);
                osc3.start(now);
                osc4.start(now);
                noise.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                env3.triggerAttack(now);
                env4.triggerAttack(now);
                noiseEnv.triggerAttack(now);

                noise.stop(now + 0.15);

                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    oscillator3: osc3,
                    oscillator4: osc4,
                    envelope: env,
                    envelope2: env2,
                    envelope3: env3,
                    envelope4: env4,
                    noise: noise,
                    noiseEnv: noiseEnv,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        env3.triggerRelease();
                        env4.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                        osc3.stop('+0.5');
                        osc4.stop('+0.5');
                        noise.stop();
                    }
                };
            }

            // Create area 1 voices connected to a given gain node (for DotMixer)
            createArea1Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createWaterVoice(freq, 0.02, 0.03, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a bell/chime sound
            createBellVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'triangle',
                    frequency: adjustedFrequency
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 2.0,
                    sustain: 0.1,
                    release: 0.5
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency * 2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 1.5,
                    sustain: 0.05,
                    release: 0.3
                });
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Create area 2 voices
            createArea2Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createBellVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a pad/string-like sound
            createPadVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.3,
                    decay: 0.2,
                    sustain: 0.7,
                    release: 0.8
                });
                
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 2000,
                    Q: 1.0
                });
                
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampTo(16000, now + 0.4);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                env.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    envelope: env,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        osc.stop('+1.0');
                    }
                };
            }

            // Create area 3 voices
            createArea3Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createPadVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a brass/synth lead sound
            createLeadVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'square',
                    frequency: adjustedFrequency * 0.5
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.85,
                    release: 0.2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.7,
                    release: 0.2
                });
                
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 3000,
                    Q: 1.0
                });
                
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampTo(12000, now + 0.1);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier * 1.5);
                const osc2Gain = new Tone.Gain(0.4);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                
                osc2.connect(env2);
                env2.connect(osc2Gain);
                osc2Gain.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Create area 4 voices
            createArea4Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createLeadVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }
        }

        // DotMixer class - manages a dot and its sound mixing with demoold.html's crossfade mechanism
        class DotMixer {
            constructor(touchId, x, y, initialArea, synth) {
                this.touchId = touchId;
                this.synth = synth;
                
                // Create visual dot
                this.dot = this.createVisualDot(x, y, initialArea);
                
                // Track area sounds: { areaNum: { voices: [...], mixGain: Tone.Gain, mixPercent: number } }
                this.areaSounds = new Map();
                
                // Master gain for this dot's mixed output
                this.masterGain = new Tone.Gain(1.0);
                this.masterGain.toDestination();
                
                // Current position
                this.currentX = x;
                this.currentY = y;
                this.currentCell = initialArea;
                
                // Crossfade constants (matching demoold.html)
                this.CROSSFADE_DURATION = 3.0; // seconds
                this.MIXRATIO_RATE = 100.0 / this.CROSSFADE_DURATION; // 33.33% per second
                this.lastUpdateTime = performance.now();
                
                // Track active areas and mix ratios (per dot)
                // Note: Mix ratios are tracked by area TYPE (1-4), not area number (1-16)
                // This allows crossfading between sound types when moving between areas
                this.areaMixRatios = { 1: 0, 2: 0, 3: 0, 4: 0 };
                this.areaMixDirections = { 1: 'none', 2: 'none', 3: 'none', 4: 'none' };
                this.activeAreas = new Set(); // Tracks area numbers (1-16) that have sounds
                
                // Start sound for initial area
                this.addAreaSound(initialArea);
                
                // Track if fading
                this.isFading = false;
            }
            
            createVisualDot(x, y, areaNum) {
                const dot = document.createElement('div');
                dot.className = 'touch-dot';
                
                // Color based on area (matching demoold.html's gradient colors)
                const colors = {
                    1: '#2a4a6a', 2: '#3a5a7a', 3: '#4a6a8a', 4: '#5a7a9a',
                    5: '#6a8aaa', 6: '#7a9aba', 7: '#8aaaca', 8: '#9abada',
                    9: '#aacaea', 10: '#badafa', 11: '#caeafa', 12: '#dafa0a',
                    13: '#ea0a1a', 14: '#fa1a2a', 15: '#0a2a3a', 16: '#1a3a4a'
                };
                dot.style.backgroundColor = colors[areaNum] || '#ffffff';
                
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                
                // Size based on X position
                const cell = cells[areaNum - 1];
                if (cell) {
                    const rect = cell.getBoundingClientRect();
                    const relativeX = x - rect.left;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    const minSize = 20;
                    const maxSize = 40;
                    const size = minSize + (normalizedX * (maxSize - minSize));
                    dot.style.width = size + 'px';
                    dot.style.height = size + 'px';
                }
                
                // Create debug info element
                const debugInfo = document.createElement('div');
                debugInfo.className = 'dot-debug-info';
                debugInfo.id = `dot-debug-${this.touchId}`;
                debugInfo.textContent = 'Vol: 0%\nMix: 0%';
                debugInfo.style.left = x + 'px';
                debugInfo.style.top = y + 'px';
                
                document.body.appendChild(dot);
                document.body.appendChild(debugInfo);
                
                this.debugInfo = debugInfo;
                return dot;
            }
            
            // Add or update area sound
            addAreaSound(areaNum) {
                if (this.areaSounds.has(areaNum)) {
                    return; // Already exists
                }
                
                // Create mix gain for this area
                const mixGain = new Tone.Gain(0); // Start at 0, will transition
                mixGain.connect(this.masterGain);
                
                // Get pitch and volume from position
                const cell = cells[areaNum - 1];
                if (!cell) return;
                
                const rect = cell.getBoundingClientRect();
                const relativeX = this.currentX - rect.left;
                const relativeY = this.currentY - rect.top;
                const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                const normalizedY = Math.max(0, Math.min(1, relativeY / rect.height));
                
                const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                const pitchOffset = 0.5 - (normalizedY * 1.0);
                
                // Create voices based on area type
                let voices = [];
                const areaType = ((areaNum - 1) % 4) + 1;
                if (areaType === 1) {
                    voices = this.synth.createArea1Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaType === 2) {
                    voices = this.synth.createArea2Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaType === 3) {
                    voices = this.synth.createArea3Voices(pitchOffset, volumeMultiplier, mixGain);
                } else {
                    voices = this.synth.createArea4Voices(pitchOffset, volumeMultiplier, mixGain);
                }
                
                this.areaSounds.set(areaNum, {
                    voices: voices,
                    mixGain: mixGain,
                    mixPercent: 0,
                    pitchOffset: pitchOffset,
                    volumeMultiplier: volumeMultiplier
                });
                
                // If this is the current cell, set mix to 100% for this area type
                if (areaNum === this.currentCell) {
                    const areaType = ((areaNum - 1) % 4) + 1;
                    this.areaMixRatios[areaType] = 100;
                    this.areaMixDirections[areaType] = 'none';
                    this.activeAreas.add(areaNum);
                    mixGain.gain.rampTo(1.0, 0.05);
                    
                    // Update debug display with initial values
                    const initialVol = volumeMultiplier * 100;
                    this.updateDebugDisplay([{
                        areaNum: areaNum,
                        areaType: areaType,
                        vol: initialVol,
                        mix: 100,
                        isCurrent: true
                    }], areaNum);
                }
            }
            
            // Update position and handle area transitions
            updatePosition(x, y, cell) {
                this.currentX = x;
                this.currentY = y;
                
                // Update dot visual position
                this.dot.style.left = x + 'px';
                this.dot.style.top = y + 'px';
                
                // Update debug info position
                if (this.debugInfo) {
                    this.debugInfo.style.left = x + 'px';
                    this.debugInfo.style.top = y + 'px';
                }
                
                if (cell) {
                    const cellNum = parseInt(cell.dataset.cell);
                    const rect = cell.getBoundingClientRect();
                    const relativeX = x - rect.left;
                    const relativeY = y - rect.top;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, relativeY / rect.height));
                    
                    // Update size
                    const minSize = 20;
                    const maxSize = 40;
                    const size = minSize + (normalizedX * (maxSize - minSize));
                    this.dot.style.width = size + 'px';
                    this.dot.style.height = size + 'px';
                    
                    // Update pitch and volume for current area
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    // Check if we're in a new area
                    if (cellNum !== this.currentCell) {
                        const oldCell = this.currentCell;
                        this.currentCell = cellNum;
                        
                        // Add new area sound if needed
                        if (!this.areaSounds.has(cellNum)) {
                            this.addAreaSound(cellNum);
                        }
                        
                        // Update mix directions for crossfade (by area type, not area number)
                        const oldAreaType = oldCell ? ((oldCell - 1) % 4) + 1 : 0;
                        const newAreaType = ((cellNum - 1) % 4) + 1;
                        
                        if (oldAreaType > 0 && oldAreaType !== newAreaType) {
                            this.areaMixDirections[oldAreaType] = 'down';
                        }
                        this.areaMixDirections[newAreaType] = 'up';
                        this.activeAreas.add(cellNum);
                    }
                    
                    // Update pitch and volume for current area's voices
                    const currentSound = this.areaSounds.get(cellNum);
                    if (currentSound) {
                        currentSound.pitchOffset = pitchOffset;
                        currentSound.volumeMultiplier = volumeMultiplier;
                        
                        // Update each voice
                        currentSound.voices.forEach((voice, index) => {
                            if (voice && voice.oscillator && voice.volumeGain) {
                                const baseFrequencies = [261.63, 329.63, 392.00];
                                const baseFreq = baseFrequencies[index];
                                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                                const newFrequency = baseFreq * pitchMultiplier;
                                
                                voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                                
                                if (voice.oscillator2) {
                                    voice.oscillator2.frequency.rampTo(newFrequency * 2, 0.05);
                                }
                                if (voice.oscillator3) {
                                    voice.oscillator3.frequency.rampTo(newFrequency * 3, 0.05);
                                }
                                if (voice.oscillator4) {
                                    voice.oscillator4.frequency.rampTo(newFrequency * 4, 0.05);
                                }
                                
                                // Update volume (account for area 4's 1.5x boost)
                                const vol = (cellNum % 4 === 0) ? volumeMultiplier * 1.5 : volumeMultiplier;
                                voice.volumeGain.gain.rampTo(vol, 0.05);
                            }
                        });
                    }
                }
                
                // Update mix percentages
                this.updateMixPercentages();
            }
            
            // Update mix percentages towards targets (matching demoold.html's mechanism)
            updateMixPercentages() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = currentTime;
                
                const clampedDeltaTime = Math.max(0.001, Math.min(deltaTime, 0.1));
                const changePerFrame = this.MIXRATIO_RATE * clampedDeltaTime;
                
                // Get current area type (1-4)
                const currentAreaType = this.currentCell ? ((this.currentCell - 1) % 4) + 1 : 0;
                
                // Update directions based on current area type
                for (let areaType = 1; areaType <= 4; areaType++) {
                    // Check if any area with this type has sound
                    let hasSoundOfType = false;
                    this.areaSounds.forEach((soundData, areaNum) => {
                        const areaTypeForArea = ((areaNum - 1) % 4) + 1;
                        if (areaTypeForArea === areaType) {
                            hasSoundOfType = true;
                        }
                    });
                    
                    const isCurrentType = (areaType === currentAreaType);
                    
                    if (isCurrentType && hasSoundOfType) {
                        if (this.areaMixRatios[areaType] < 100) {
                            this.areaMixDirections[areaType] = 'up';
                        } else {
                            this.areaMixDirections[areaType] = 'none';
                        }
                    } else if (hasSoundOfType) {
                        if (this.areaMixRatios[areaType] > 0) {
                            this.areaMixDirections[areaType] = 'down';
                        } else {
                            this.areaMixDirections[areaType] = 'none';
                        }
                    }
                }
                
                // Update mix ratios by area type (1-4)
                for (let areaType = 1; areaType <= 4; areaType++) {
                    const direction = this.areaMixDirections[areaType] || 'none';
                    let newMix = this.areaMixRatios[areaType];
                    
                    if (direction === 'up') {
                        newMix = Math.min(100, newMix + changePerFrame);
                    } else if (direction === 'down') {
                        newMix = Math.max(0, newMix - changePerFrame);
                    }
                    
                    this.areaMixRatios[areaType] = newMix;
                    
                    // Apply this mix ratio to all areas of this type
                    this.areaSounds.forEach((soundData, areaNum) => {
                        const areaTypeForArea = ((areaNum - 1) % 4) + 1;
                        if (areaTypeForArea === areaType) {
                            soundData.mixPercent = newMix;
                            // Update gain (convert percentage to 0-1 range)
                            soundData.mixGain.gain.rampTo(newMix / 100, 0.05);
                        }
                    });
                }
                
                // Collect all active areas with their volumes and mix percentages
                const activeAreaInfo = [];
                
                this.areaSounds.forEach((soundData, areaNum) => {
                    const areaType = ((areaNum - 1) % 4) + 1;
                    const mix = this.areaMixRatios[areaType];
                    
                    // Calculate volume for this area (only if mix > 0)
                    if (mix > 0.1) {
                        let maxVolume = 0;
                        soundData.voices.forEach(voice => {
                            if (voice && voice.volumeGain) {
                                try {
                                    const voiceVol = voice.volumeGain.gain.value;
                                    const mixVol = soundData.mixGain.gain.value;
                                    const totalVol = voiceVol * mixVol; // Combined volume
                                    maxVolume = Math.max(maxVolume, totalVol);
                                } catch (e) {
                                    // Fallback
                                    const baseVol = soundData.volumeMultiplier || 0;
                                    const mixVol = mix / 100;
                                    maxVolume = Math.max(maxVolume, baseVol * mixVol);
                                }
                            }
                        });
                        
                        const isCurrentArea = (areaNum === this.currentCell);
                        activeAreaInfo.push({
                            areaNum: areaNum,
                            areaType: areaType,
                            vol: maxVolume * 100, // Convert to percentage
                            mix: mix,
                            isCurrent: isCurrentArea
                        });
                    }
                    
                    // Cleanup if mix reaches 0
                    if (mix <= 0.1 && !this.activeAreas.has(areaNum)) {
                        this.cleanupAreaSound(areaNum);
                    }
                });
                
                // Sort by area number for consistent display
                activeAreaInfo.sort((a, b) => a.areaNum - b.areaNum);
                
                // Update debug display with all active areas
                this.updateDebugDisplay(activeAreaInfo, this.currentCell);
            }
            
            // Update debug display for this dot - show all active areas
            updateDebugDisplay(activeAreaInfo, currentCell) {
                if (!this.debugInfo) return;
                
                if (activeAreaInfo.length === 0) {
                    this.debugInfo.textContent = `Area: ${currentCell || '?'}\nNo active sounds`;
                    return;
                }
                
                // Build display text
                let text = `Area: ${currentCell || '?'}\n`;
                
                activeAreaInfo.forEach((info, index) => {
                    const marker = info.isCurrent ? 'â†’' : ' ';
                    text += `${marker}A${info.areaNum}: Vol${info.vol.toFixed(0)}% Mix${info.mix.toFixed(0)}%\n`;
                });
                
                // Remove trailing newline
                text = text.trim();
                
                this.debugInfo.textContent = text;
            }
            
            cleanupAreaSound(areaNum) {
                const soundData = this.areaSounds.get(areaNum);
                if (!soundData) return;
                
                // Release all voices
                soundData.voices.forEach(voice => {
                    if (voice && voice.stop) {
                        voice.stop();
                    }
                });
                
                // Dispose gain
                soundData.mixGain.disconnect();
                soundData.mixGain.dispose();
                
                this.areaSounds.delete(areaNum);
                // Note: Don't reset areaMixRatios here - they're shared by area type
                // They'll be reset naturally when all areas of that type are cleaned up
            }
            
            // Start fade and release sounds
            startFade() {
                if (this.isFading) return;
                this.isFading = true;
                
                // Release all sounds using ADSR release (matching demoold.html)
                this.areaSounds.forEach((soundData, areaNum) => {
                    soundData.voices.forEach(voice => {
                        if (voice) {
                            if (voice.envelope) voice.envelope.triggerRelease();
                            if (voice.envelope2) voice.envelope2.triggerRelease();
                            if (voice.envelope3) voice.envelope3.triggerRelease();
                            if (voice.envelope4) voice.envelope4.triggerRelease();
                            if (voice.noiseEnv) voice.noiseEnv.triggerRelease();
                        }
                    });
                });
                
                // Start visual fade
                this.dot.style.opacity = '0';
                
                // Cleanup after fade
                setTimeout(() => {
                    this.areaSounds.forEach((soundData, areaNum) => {
                        this.cleanupAreaSound(areaNum);
                    });
                    if (this.dot && this.dot.parentNode) {
                        this.dot.parentNode.removeChild(this.dot);
                    }
                    if (this.debugInfo && this.debugInfo.parentNode) {
                        this.debugInfo.parentNode.removeChild(this.debugInfo);
                    }
                    this.masterGain.disconnect();
                    this.masterGain.dispose();
                }, 2000);
            }
        }

        // Initialize synth
        let synth = null;

        // Initialize on user interaction
        function initAudio() {
            if (synth) return;
            
            Tone.start().then(() => {
                synth = new WaterSynthTone();
                console.log('Audio initialized');
            });
        }

        // Get all grid cells
        const cells = document.querySelectorAll('.grid-cell');

        // Multitouch tracking - using DotMixer instances
        const dotMixers = new Map(); // Map of touchId -> DotMixer instance

        // Helper function to find cell from coordinates
        function findCellFromCoordinates(x, y) {
            const gridContainer = document.querySelector('.grid-container');
            if (!gridContainer) return null;
            
            const rect = gridContainer.getBoundingClientRect();
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            
            const cellWidth = rect.width / 4;
            const cellHeight = rect.height / 4;
            
            const col = Math.floor(relativeX / cellWidth);
            const row = Math.floor(relativeY / cellHeight);
            
            if (col < 0 || col >= 4 || row < 0 || row >= 4) return null;
            
            const cellIndex = row * 4 + col;
            return cells[cellIndex] || null;
        }

        // Multitouch-aware touch handlers
        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();
            
            if (!synth) return;
            
            // Process all touches
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                
                if (cell) {
                    // Limit to maximum 6 dots
                    const MAX_DOTS = 6;
                    if (dotMixers.size >= MAX_DOTS) {
                        const oldestTouchId = dotMixers.keys().next().value;
                        if (oldestTouchId !== undefined) {
                            const oldestMixer = dotMixers.get(oldestTouchId);
                            if (oldestMixer) {
                                oldestMixer.startFade();
                            }
                            dotMixers.delete(oldestTouchId);
                        }
                    }
                    
                    const cellNum = parseInt(cell.dataset.cell);
                    const mixer = new DotMixer(touchId, touch.clientX, touch.clientY, cellNum, synth);
                    dotMixers.set(touchId, mixer);
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            // Check for orphaned touches
            const activeTouchIds = new Set();
            for (let i = 0; i < e.touches.length; i++) {
                activeTouchIds.add(e.touches[i].identifier);
            }
            
            // Remove orphaned dots
            dotMixers.forEach((mixer, touchId) => {
                if (!activeTouchIds.has(touchId)) {
                    mixer.startFade();
                    dotMixers.delete(touchId);
                }
            });
            
            // Update all active touches
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchId = touch.identifier;
                
                const mixer = dotMixers.get(touchId);
                if (!mixer || mixer.isFading) continue;
                
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                mixer.updatePosition(touch.clientX, touch.clientY, cell);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Process all touches
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                const mixer = dotMixers.get(touchId);
                if (mixer) {
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(touchId);
                    }, 2100);
                }
            }
        }

        // Mouse events for desktop (simulating touch)
        let mouseTouchId = null;
        
        document.addEventListener('mousedown', (e) => {
            e.preventDefault();
            initAudio();
            if (!synth) return;
            
            const cell = findCellFromCoordinates(e.clientX, e.clientY);
            if (!cell) return;
            
            // Limit to maximum 6 dots
            const MAX_DOTS = 6;
            if (dotMixers.size >= MAX_DOTS) {
                const oldestTouchId = dotMixers.keys().next().value;
                if (oldestTouchId !== undefined) {
                    const oldestMixer = dotMixers.get(oldestTouchId);
                    if (oldestMixer) {
                        oldestMixer.startFade();
                    }
                    dotMixers.delete(oldestTouchId);
                }
            }
            
            mouseTouchId = 'mouse_' + Date.now();
            const cellNum = parseInt(cell.dataset.cell);
            const mixer = new DotMixer(mouseTouchId, e.clientX, e.clientY, cellNum, synth);
            dotMixers.set(mouseTouchId, mixer);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (e.buttons === 1 && mouseTouchId) {
                const mixer = dotMixers.get(mouseTouchId);
                if (mixer && !mixer.isFading) {
                    const cell = findCellFromCoordinates(e.clientX, e.clientY);
                    mixer.updatePosition(e.clientX, e.clientY, cell);
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (mouseTouchId) {
                const mixer = dotMixers.get(mouseTouchId);
                if (mixer) {
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(mouseTouchId);
                    }, 2100);
                }
                mouseTouchId = null;
            }
        });

        // Add global touch event listeners
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Continuous update loop for mix percentages (60fps)
        function updateAllDotMixers() {
            dotMixers.forEach((mixer) => {
                if (!mixer.isFading) {
                    mixer.updateMixPercentages();
                }
            });
        }
        
        setInterval(updateAllDotMixers, 1000 / 60);

        // Cleanup on visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                dotMixers.forEach((mixer) => {
                    mixer.startFade();
                });
                dotMixers.clear();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            dotMixers.forEach((mixer) => {
                mixer.startFade();
            });
        });
    </script>
</body>
</html>

