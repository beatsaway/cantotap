<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Synth Grid Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100vw;
            height: 100vh;
            gap: 0;
        }

        .grid-cell {
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.1s;
        }

        .grid-cell:active,
        .grid-cell.active {
            background-color: rgba(100, 150, 255, 0.3);
        }

        /* Grid cell colors will be set via JavaScript to match area colors */

        /* Touch dot visualization */
        .touch-dot {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            pointer-events: none !important;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: opacity 2s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            will-change: transform;
            opacity: 1;
        }

        /* Area colors are now set inline via JavaScript */
    </style>
</head>
<body>
    <div class="grid-container">
        <div class="grid-cell" data-cell="1">Area 1<br>Chord</div>
        <div class="grid-cell" data-cell="2">Area 2</div>
        <div class="grid-cell" data-cell="3">Area 3</div>
        <div class="grid-cell" data-cell="4">Area 4</div>
        <div class="grid-cell" data-cell="5">Area 5</div>
        <div class="grid-cell" data-cell="6">Area 6</div>
        <div class="grid-cell" data-cell="7">Area 7</div>
        <div class="grid-cell" data-cell="8">Area 8</div>
        <div class="grid-cell" data-cell="9">Area 9</div>
        <div class="grid-cell" data-cell="10">Area 10</div>
        <div class="grid-cell" data-cell="11">Area 11</div>
        <div class="grid-cell" data-cell="12">Area 12</div>
        <div class="grid-cell" data-cell="13">Area 13</div>
        <div class="grid-cell" data-cell="14">Area 14</div>
        <div class="grid-cell" data-cell="15">Area 15</div>
        <div class="grid-cell" data-cell="16">Area 16</div>
    </div>

    <script>
        // Water Synth using Tone.js - inspired by watersynth.js
        // 
        // KEY ELEMENTS THAT MAKE THE SOUND BETTER:
        // 1. PITCH ATTACK: Starts at higher frequency (frequency + pitchDrop), then
        //    exponential ramp down to target frequency. This creates the "plink" or
        //    "droplet" attack sound that mimics water physics.
        // 2. EXPONENTIAL RAMP: Uses exponentialRampTo (not linear) for more natural
        //    pitch drop curve - sounds more organic than linear ramps.
        // 3. NOISE COMPONENT: Adds texture with shaped noise that decays quickly,
        //    simulating the initial impact/attack transient.
        // 4. AMPLITUDE ENVELOPE: Fast attack (0.02s), quick decay to sustain (0.35),
        //    creates a natural attack-sustain-release pattern.
        // 5. WET REVERB: Very wet reverb signal (77% wet) creates spacious, ambient
        //    tail that makes the sound feel more immersive.
        // 6. NATURAL VARIATIONS: Random variations in pitchDrop, noiseAmount create
        //    organic, non-mechanical sound.
        //
        class WaterSynthTone {
            constructor() {
                // Create reverb with very wet signal (like original: 1.0 reverb, 0.3 dry)
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 0.77  // Very wet reverb (1.0 / (1.0 + 0.3))
                }).toDestination();

                // Create compressor/limiter
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                }).connect(this.reverb);

                // Create EQ for natural rolloff (for area 2/bell sounds)
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                }).connect(this.compressor);

                // Master gain - split into dry and wet paths
                this.masterGain = new Tone.Gain(1.0);
                this.dryGain = new Tone.Gain(0.3).connect(this.eq);  // Less dry signal (for bell/area 2)
                this.reverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Very loud reverb
                
                // Separate path for area 1 (water sounds) - bypasses filter
                this.area1DryGain = new Tone.Gain(0.3).connect(this.compressor);  // Direct to compressor, no filter
                this.area1ReverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Reverb path
                
                // Connect master to both paths (for bell/area 2)
                this.masterGain.connect(this.dryGain);
                this.masterGain.connect(this.reverbGain);
                
                // Separate master gain for area 1 (no filter)
                this.masterGainArea1 = new Tone.Gain(1.0);
                this.masterGainArea1.connect(this.area1DryGain);
                this.masterGainArea1.connect(this.area1ReverbGain);

                // Generate reverb impulse response
                this.reverb.generate().catch(console.error);

                // Store active voices for chord
                this.activeVoices = [];
                
                // Store active bell voices for chord
                this.activeBellVoices = [];
                
                // Store active pad voices for chord (area 3)
                this.activePadVoices = [];
                
                // Store active brass voices for chord (area 4)
                this.activeBrassVoices = [];
                
                // Store current pitch offset and volume for updates
                this.currentPitchOffset = 0;
                this.currentVolumeMultiplier = 1.0;
            }

            // Create a water-like sound with pitch drop and noise
            createWaterVoice(frequency, pitchDrop = 0.02, noiseAmount = 0.03, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Add natural variation (like original)
                const finalPitchDrop = frequency * (pitchDrop + Math.random() * 0.02);
                const finalNoiseAmount = noiseAmount * (0.8 + Math.random() * 0.4);

                // Apply pitch offset (in semitones, converted to frequency ratio)
                // Quarter step = 0.5 semitones = 2^(0.5/12) frequency multiplier
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;

                // Main oscillator with pitch drop on attack
                // KEY: Start higher, then exponential ramp down (creates the "plink" attack)
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency + finalPitchDrop
                });

                // Frequency envelope for pitch drop - exponential ramp (more natural than linear)
                // This is the KEY to the interesting pitch attack!
                // The exponential curve creates a natural-sounding pitch drop that mimics
                // the physics of a water droplet hitting a surface
                osc.frequency.exponentialRampTo(adjustedFrequency, 0.08);

                // Add harmonic oscillators for mid-high frequency content
                // 2nd harmonic (octave) - adds brightness
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 2) + (finalPitchDrop * 2)
                });
                osc2.frequency.exponentialRampTo(adjustedFrequency * 2, 0.08);
                
                // 3rd harmonic - adds mid-high character
                const osc3 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 3) + (finalPitchDrop * 3)
                });
                osc3.frequency.exponentialRampTo(adjustedFrequency * 3, 0.08);
                
                // 4th harmonic - adds high frequency sparkle
                const osc4 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 4) + (finalPitchDrop * 4)
                });
                osc4.frequency.exponentialRampTo(adjustedFrequency * 4, 0.08);

                // Amplitude envelope - matches original: peak at 0.5, settle to 0.35
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.02,      // Fast attack (matches original)
                    decay: 0.01,       // Quick decay to sustain
                    sustain: 0.35,     // Sustain level (matches original)
                    release: 0.3       // Release time
                });
                
                // Separate envelopes for harmonics (slightly different for natural sound)
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.25,     // Lower sustain for harmonics
                    release: 0.3
                });
                
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.15,     // Even lower for higher harmonics
                    release: 0.3
                });
                
                const env4 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.1,     // Lowest for highest harmonic
                    release: 0.3
                });
                
                // Gain controls for harmonic levels (relative to fundamental)
                const harmonicGain2 = new Tone.Gain(0.3);  // 2nd harmonic at 30% of fundamental
                const harmonicGain3 = new Tone.Gain(0.2);  // 3rd harmonic at 20%
                const harmonicGain4 = new Tone.Gain(0.1);  // 4th harmonic at 10%

                // Noise component with shaped envelope (simulates the original's quadratic falloff)
                // The original uses custom noise buffer with quadratic decay, but we can
                // approximate it with white noise + fast exponential decay envelope
                const noise = new Tone.Noise({
                    type: 'white',
                    volume: -20
                });

                // Noise envelope with fast exponential decay (mimics quadratic falloff)
                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,       // Noise decays quickly (matches original 0.1s exponential ramp)
                    sustain: 0,
                    release: 0
                });

                // Set noise volume based on noiseAmount
                const noiseGain = new Tone.Gain();
                noiseGain.gain.value = finalNoiseAmount * 0.5;  // Scale noise appropriately

                // Panning for stereo width (subtle like original: 0.15 max pan)
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);

                // Volume control based on position - increased to match other areas' perceived loudness
                const volumeGain = new Tone.Gain(volumeMultiplier * 1.2);

                // Connect: osc -> env -> volumeGain -> pan -> masterGainArea1 (bypasses filter)
                osc.connect(env);
                env.connect(volumeGain);
                
                // Connect harmonics: osc2/3/4 -> env2/3/4 -> harmonicGain -> volumeGain
                osc2.connect(env2);
                env2.connect(harmonicGain2);
                harmonicGain2.connect(volumeGain);
                
                osc3.connect(env3);
                env3.connect(harmonicGain3);
                harmonicGain3.connect(volumeGain);
                
                osc4.connect(env4);
                env4.connect(harmonicGain4);
                harmonicGain4.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGainArea1);

                // Connect noise: noise -> noiseGain -> noiseEnv -> pan
                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);

                // Start
                osc.start(now);
                osc2.start(now);
                osc3.start(now);
                osc4.start(now);
                noise.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                env3.triggerAttack(now);
                env4.triggerAttack(now);
                noiseEnv.triggerAttack(now);

                // Stop noise after short time (matches original: 0.15s)
                noise.stop(now + 0.15);

                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    oscillator3: osc3,
                    oscillator4: osc4,
                    envelope: env,
                    envelope2: env2,
                    envelope3: env3,
                    envelope4: env4,
                    noise: noise,
                    noiseEnv: noiseEnv,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        env3.triggerRelease();
                        env4.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                        osc3.stop('+0.5');
                        osc4.stop('+0.5');
                        noise.stop();
                    }
                };
            }

            // Play a chord (for area 1)
            playChord(pitchOffset = 0, volumeMultiplier = 1.0) {
                // Store current values
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // C major chord: C, E, G
                const chordFrequencies = [
                    261.63, // C4
                    329.63, // E4
                    392.00  // G4
                ];

                this.activeVoices = chordFrequencies.map(freq => 
                    this.createWaterVoice(freq, 0.02, 0.03, pitchOffset, volumeMultiplier)
                );
            }
            
            // Update chord pitch and volume in real-time
            updateChord(pitchOffset, volumeMultiplier) {
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // Update each voice
                this.activeVoices.forEach((voice, index) => {
                    if (voice && voice.oscillator && voice.volumeGain) {
                        // Base frequencies for the chord
                        const baseFrequencies = [261.63, 329.63, 392.00];
                        const baseFreq = baseFrequencies[index];
                        
                        // Calculate new frequency with pitch offset
                        const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                        const newFrequency = baseFreq * pitchMultiplier;
                        
                        // Update frequency (smooth transition)
                        voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                        
                        // Update harmonic frequencies
                        if (voice.oscillator2) {
                            voice.oscillator2.frequency.rampTo(newFrequency * 2, 0.05);
                        }
                        if (voice.oscillator3) {
                            voice.oscillator3.frequency.rampTo(newFrequency * 3, 0.05);
                        }
                        if (voice.oscillator4) {
                            voice.oscillator4.frequency.rampTo(newFrequency * 4, 0.05);
                        }
                        
                        // Update volume - increased to match other areas' perceived loudness
                        voice.volumeGain.gain.rampTo(volumeMultiplier * 1.2, 0.05);
                    }
                });
            }

            // Release the chord
            releaseChord() {
                this.activeVoices.forEach(voice => {
                    if (voice && voice.stop) {
                        voice.stop();
                    }
                });
                this.activeVoices = [];
            }

            // Create area 1 voices connected to a given gain node (for DotMixer)
            createArea1Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createWaterVoice(freq, 0.02, 0.03, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create area 2 voices connected to a given gain node (for DotMixer)
            createArea2Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createBellVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create area 3 voices connected to a given gain node (for DotMixer)
            createArea3Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createPadVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create area 4 voices connected to a given gain node (for DotMixer)
            createArea4Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createBrassVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a bell/chime sound (different from water sound)
            createBellVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Apply pitch offset
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                // Bell uses triangle wave with harmonics for richer timbre
                const osc = new Tone.Oscillator({
                    type: 'triangle',
                    frequency: adjustedFrequency
                });
                
                // Bell envelope: fast attack, long decay, no sustain
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 2.0,      // Long decay for bell-like sustain
                    sustain: 0.1,     // Low sustain
                    release: 0.5
                });
                
                // Add a second oscillator an octave higher for bell harmonics
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency * 2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 1.5,
                    sustain: 0.05,
                    release: 0.3
                });
                
                // Panning for stereo width
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                
                // Volume control - increased to match other areas' perceived loudness
                const volumeGain = new Tone.Gain(volumeMultiplier * 1.1);
                
                // Connect: osc -> env -> volumeGain -> pan -> masterGain
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                // Start
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Play a bell chord (for area 2) - same chord as area 1
            playBell(pitchOffset = 0, volumeMultiplier = 1.0) {
                // Store current values
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // C major chord: C, E, G (same as area 1)
                const chordFrequencies = [
                    261.63, // C4
                    329.63, // E4
                    392.00  // G4
                ];
                
                // Release any existing bell voices
                if (this.activeBellVoices) {
                    this.activeBellVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                
                this.activeBellVoices = chordFrequencies.map(freq => 
                    this.createBellVoice(freq, pitchOffset, volumeMultiplier)
                );
            }
            
            // Update bell chord pitch and volume in real-time
            updateBell(pitchOffset, volumeMultiplier) {
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // Base frequencies for the chord
                const baseFrequencies = [261.63, 329.63, 392.00];
                
                // Update each voice
                if (this.activeBellVoices) {
                    this.activeBellVoices.forEach((voice, index) => {
                        if (voice && voice.oscillator && voice.volumeGain) {
                            const baseFreq = baseFrequencies[index];
                            const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                            const newFrequency = baseFreq * pitchMultiplier;
                            
                            // Update frequencies (smooth transition)
                            voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                            if (voice.oscillator2) {
                                voice.oscillator2.frequency.rampTo(newFrequency * 2, 0.05);
                            }
                            
                            // Update volume - increased to match other areas' perceived loudness
                            voice.volumeGain.gain.rampTo(volumeMultiplier * 1.1, 0.05);
                        }
                    });
                }
            }
            
            // Release the bell chord
            releaseBell() {
                if (this.activeBellVoices) {
                    this.activeBellVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                this.activeBellVoices = [];
            }

            // Create a pad/string-like sound (for area 3)
            createPadVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Apply pitch offset
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                // Pad uses sawtooth wave for rich harmonic content
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                // Pad envelope: slow attack, long sustain, slow release
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.3,      // Slow attack for pad-like feel
                    decay: 0.2,
                    sustain: 0.7,      // High sustain
                    release: 0.8      // Slow release
                });
                
                // Add lowpass filter for warmth (sweeps during attack)
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 2000,   // Start low
                    Q: 1.0
                });
                
                // Filter sweep - opens up during attack for brightness
                // Start at 2000Hz, ramp to 16000Hz during attack
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampTo(16000, now + 0.4);
                
                // Panning for stereo width
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                
                // Volume control - reduced slightly to match other areas' perceived loudness
                const volumeGain = new Tone.Gain(volumeMultiplier * 0.85);
                
                // Connect: osc -> filter -> env -> volumeGain -> pan -> masterGain
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                // Start
                osc.start(now);
                env.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    envelope: env,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        osc.stop('+1.0');
                    }
                };
            }

            // Play a pad chord (for area 3) - same chord as area 1
            playPad(pitchOffset = 0, volumeMultiplier = 1.0) {
                // Store current values
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // C major chord: C, E, G (same as area 1)
                const chordFrequencies = [
                    261.63, // C4
                    329.63, // E4
                    392.00  // G4
                ];
                
                // Release any existing pad voices
                if (this.activePadVoices) {
                    this.activePadVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                
                this.activePadVoices = chordFrequencies.map(freq => 
                    this.createPadVoice(freq, pitchOffset, volumeMultiplier)
                );
            }
            
            // Update pad chord pitch and volume in real-time
            updatePad(pitchOffset, volumeMultiplier) {
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // Base frequencies for the chord
                const baseFrequencies = [261.63, 329.63, 392.00];
                
                // Update each voice
                if (this.activePadVoices) {
                    this.activePadVoices.forEach((voice, index) => {
                        if (voice && voice.oscillator && voice.volumeGain) {
                            const baseFreq = baseFrequencies[index];
                            const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                            const newFrequency = baseFreq * pitchMultiplier;
                            
                            // Update frequency (smooth transition)
                            voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                            
                            // Update volume - reduced slightly to match other areas' perceived loudness
                            voice.volumeGain.gain.rampTo(volumeMultiplier * 0.85, 0.05);
                        }
                    });
                }
            }
            
            // Release the pad chord
            releasePad() {
                if (this.activePadVoices) {
                    this.activePadVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                this.activePadVoices = [];
            }

            // Create a brass/synth lead sound (for area 4) - loud and punchy
            createBrassVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Apply pitch offset
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                // Main oscillator - sawtooth for rich harmonics
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                // Second oscillator - square wave an octave lower for body
                const osc2 = new Tone.Oscillator({
                    type: 'square',
                    frequency: adjustedFrequency * 0.5
                });
                
                // Brass-like envelope: medium attack, high sustain
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.05,     // Quick but not instant
                    decay: 0.1,
                    sustain: 0.85,    // High sustain for loudness
                    release: 0.2      // Quick release
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.7,     // Slightly lower for balance
                    release: 0.2
                });
                
                // Lowpass filter for warmth - opens during attack
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 3000,   // Start somewhat bright
                    Q: 1.0
                });
                
                // Filter opens up during attack for brightness
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampTo(12000, now + 0.1);
                
                // Panning for stereo width
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                
                // Volume control - reduced to match other areas' perceived loudness
                const volumeGain = new Tone.Gain(volumeMultiplier * 0.7);
                
                // Gain for second oscillator
                const osc2Gain = new Tone.Gain(0.4);  // 40% of main oscillator
                
                // Connect: osc -> filter -> env -> volumeGain -> pan -> masterGain
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                
                // Connect second oscillator
                osc2.connect(env2);
                env2.connect(osc2Gain);
                osc2Gain.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                // Start
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Play a brass/synth lead chord (for area 4) - same chord as area 1
            playBrass(pitchOffset = 0, volumeMultiplier = 1.0) {
                // Store current values
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // C major chord: C, E, G (same as area 1)
                const chordFrequencies = [
                    261.63, // C4
                    329.63, // E4
                    392.00  // G4
                ];
                
                // Release any existing brass voices
                if (this.activeBrassVoices) {
                    this.activeBrassVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                
                this.activeBrassVoices = chordFrequencies.map(freq => 
                    this.createBrassVoice(freq, pitchOffset, volumeMultiplier)
                );
            }
            
            // Update brass/synth lead chord pitch and volume in real-time
            updateBrass(pitchOffset, volumeMultiplier) {
                this.currentPitchOffset = pitchOffset;
                this.currentVolumeMultiplier = volumeMultiplier;
                
                // Base frequencies for the chord
                const baseFrequencies = [261.63, 329.63, 392.00];
                
                // Update each voice
                if (this.activeBrassVoices) {
                    this.activeBrassVoices.forEach((voice, index) => {
                        if (voice && voice.oscillator && voice.volumeGain) {
                            const baseFreq = baseFrequencies[index];
                            const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                            const newFrequency = baseFreq * pitchMultiplier;
                            
                            // Update frequency (smooth transition)
                            voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                            
                            // Update second oscillator (octave below)
                            if (voice.oscillator2) {
                                voice.oscillator2.frequency.rampTo(newFrequency * 0.5, 0.05);
                            }
                            
                            // Update filter frequency (keep it open)
                            if (voice.filter) {
                                voice.filter.frequency.rampTo(12000, 0.05);
                            }
                            
                            // Update volume - reduced to match other areas' perceived loudness
                            voice.volumeGain.gain.rampTo(volumeMultiplier * 0.7, 0.05);
                        }
                    });
                }
            }
            
            // Release the brass/synth lead chord
            releaseBrass() {
                if (this.activeBrassVoices) {
                    this.activeBrassVoices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                }
                this.activeBrassVoices = [];
            }
        }

        // DotMixer class - manages a dot and its sound mixing
        class DotMixer {
            constructor(touchId, x, y, areaColor, normalizedX, initialArea, synth) {
                this.touchId = touchId;
                this.synth = synth;
                
                // Create visual dot
                this.dot = this.createVisualDot(x, y, areaColor, normalizedX);
                
                // Track area sounds: { areaNum: { voices: [...], mixGain: Tone.Gain, mixPercent: number, targetMix: number } }
                this.areaSounds = new Map();
                
                // Master gain for this dot's mixed output
                this.masterGain = new Tone.Gain(1.0);
                this.masterGain.toDestination();
                
                // Mix transition rate (per frame/update)
                this.mixTransitionRate = 0.05; // 5% per update
                
                // Current position
                this.currentX = x;
                this.currentY = y;
                this.currentCell = initialArea;
                
                // Start sound for initial area
                this.addAreaSound(initialArea, 1.0);
                
                // Track if fading (for cleanup)
                this.isFading = false;
            }
            
            createVisualDot(x, y, areaColor, normalizedX) {
                const dot = document.createElement('div');
                dot.className = 'touch-dot';
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                dot.style.backgroundColor = areaColor;
                
                // Size based on X position: left (0) = 20px, right (1) = 40px
                const minSize = 20;
                const maxSize = 40;
                const size = minSize + (normalizedX * (maxSize - minSize));
                dot.style.width = size + 'px';
                dot.style.height = size + 'px';
                
                document.body.appendChild(dot);
                return dot;
            }
            
            // Add or update area sound
            addAreaSound(areaNum, targetMix) {
                if (this.areaSounds.has(areaNum)) {
                    // Update target mix
                    this.areaSounds.get(areaNum).targetMix = targetMix;
                    return;
                }
                
                // Create new area sound
                const mixGain = new Tone.Gain(0); // Start at 0, will transition to targetMix
                mixGain.connect(this.masterGain);
                
                // Get pitch and volume from position (same logic as before)
                const cell = cells[areaNum - 1];
                if (!cell) return;
                
                const rect = cell.getBoundingClientRect();
                const relativeX = this.currentX - rect.left;
                const relativeY = this.currentY - rect.top;
                const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                const normalizedY = Math.max(0, Math.min(1, relativeY / rect.height));
                
                const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                const pitchOffset = 0.5 - (normalizedY * 1.0);
                
                // Create voices based on area type
                let voices = [];
                if (areaNum === 1) {
                    voices = this.synth.createArea1Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaNum === 2) {
                    voices = this.synth.createArea2Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaNum === 3) {
                    voices = this.synth.createArea3Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaNum === 4) {
                    voices = this.synth.createArea4Voices(pitchOffset, volumeMultiplier, mixGain);
                } else {
                    // For areas 5-16, cycle through area types
                    const areaType = ((areaNum - 1) % 4) + 1;
                    if (areaType === 1) {
                        voices = this.synth.createArea1Voices(pitchOffset, volumeMultiplier, mixGain);
                    } else if (areaType === 2) {
                        voices = this.synth.createArea2Voices(pitchOffset, volumeMultiplier, mixGain);
                    } else if (areaType === 3) {
                        voices = this.synth.createArea3Voices(pitchOffset, volumeMultiplier, mixGain);
                    } else {
                        voices = this.synth.createArea4Voices(pitchOffset, volumeMultiplier, mixGain);
                    }
                }
                
                this.areaSounds.set(areaNum, {
                    voices: voices,
                    mixGain: mixGain,
                    mixPercent: 0,
                    targetMix: targetMix
                });
            }
            
            // Update position and handle area transitions
            updatePosition(x, y, cell) {
                this.currentX = x;
                this.currentY = y;
                
                // Update dot visual position and size
                this.dot.style.left = x + 'px';
                this.dot.style.top = y + 'px';
                
                if (cell) {
                    const cellNum = parseInt(cell.dataset.cell);
                    const rect = cell.getBoundingClientRect();
                    const relativeX = x - rect.left;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    
                    // Update size
                    const minSize = 20;
                    const maxSize = 40;
                    const size = minSize + (normalizedX * (maxSize - minSize));
                    this.dot.style.width = size + 'px';
                    this.dot.style.height = size + 'px';
                    
                    // Check if we're in a new area
                    if (cellNum !== this.currentCell) {
                        this.currentCell = cellNum;
                        
                        // If this area already has a sound, increase its mix
                        if (this.areaSounds.has(cellNum)) {
                            this.areaSounds.get(cellNum).targetMix = 1.0;
                        } else {
                            // Add new area sound at 100%
                            this.addAreaSound(cellNum, 1.0);
                        }
                    }
                }
                
                // Update all area sounds' mix percentages
                this.updateMixPercentages();
            }
            
            // Update mix percentages towards targets
            updateMixPercentages() {
                this.areaSounds.forEach((soundData, areaNum) => {
                    const currentMix = soundData.mixPercent;
                    const targetMix = soundData.targetMix;
                    
                    // If in this area, target is 100%, otherwise 0%
                    const isInArea = (areaNum === this.currentCell);
                    const newTarget = isInArea ? 1.0 : 0.0;
                    soundData.targetMix = newTarget;
                    
                    // Transition towards target
                    let newMix;
                    if (currentMix < newTarget) {
                        // Increasing
                        newMix = Math.min(1.0, currentMix + this.mixTransitionRate);
                    } else if (currentMix > newTarget) {
                        // Decreasing
                        newMix = Math.max(0.0, currentMix - this.mixTransitionRate);
                    } else {
                        newMix = currentMix;
                    }
                    
                    soundData.mixPercent = newMix;
                    soundData.mixGain.gain.value = newMix;
                    
                    // If mix reaches 0 and we're not in this area, we could clean up
                    // But we'll keep it until dot fades to allow re-entry
                });
            }
            
            // Start fade and release sounds
            startFade() {
                if (this.isFading) return;
                this.isFading = true;
                
                // Start visual fade
                this.dot.style.opacity = '0';
                
                // Release all sounds after fade completes
                setTimeout(() => {
                    this.releaseAllSounds();
                    if (this.dot && this.dot.parentNode) {
                        this.dot.parentNode.removeChild(this.dot);
                    }
                }, 2000);
            }
            
            // Release all sounds and clean up
            releaseAllSounds() {
                this.areaSounds.forEach((soundData, areaNum) => {
                    // Release all voices
                    soundData.voices.forEach(voice => {
                        if (voice && voice.stop) {
                            voice.stop();
                        }
                    });
                    
                    // Disconnect and dispose
                    soundData.mixGain.disconnect();
                    soundData.mixGain.dispose();
                });
                
                this.areaSounds.clear();
                this.masterGain.disconnect();
                this.masterGain.dispose();
            }
        }

        // Initialize synth
        let synth = null;

        // Initialize on user interaction (required for audio context)
        function initAudio() {
            if (synth) return;
            
            Tone.start().then(() => {
                synth = new WaterSynthTone();
                console.log('Audio initialized');
            });
        }

        // Get all grid cells
        const cells = document.querySelectorAll('.grid-cell');

        // Multitouch tracking - now using DotMixer instances
        const dotMixers = new Map(); // Map of touchId -> DotMixer instance

        // Color mapping for each area (16 areas total) - carefully chosen for maximum distinguishability
        const areaColors = [
            '#ff6b6b', // Area 1 - Red
            '#4ecdc4', // Area 2 - Teal/Cyan
            '#ffe66d', // Area 3 - Yellow
            '#ff8b94', // Area 4 - Pink
            '#6bcf7f', // Area 5 - Green
            '#aa96da', // Area 6 - Purple
            '#ffa07a', // Area 7 - Light Salmon
            '#20b2aa', // Area 8 - Light Sea Green
            '#ffd700', // Area 9 - Gold
            '#87ceeb', // Area 10 - Sky Blue
            '#ff69b4', // Area 11 - Hot Pink
            '#32cd32', // Area 12 - Lime Green
            '#ff6347', // Area 13 - Tomato
            '#9370db', // Area 14 - Medium Purple
            '#00ced1', // Area 15 - Dark Turquoise
            '#ff1493'  // Area 16 - Deep Pink
        ];

        // Helper function to darken a color for gradient
        function darkenColor(color, amount) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.min(255, (num >> 16) - amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) - amount));
            const b = Math.max(0, Math.min(255, (num & 0x0000FF) - amount));
            return "#" + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Apply colors to grid cells
        cells.forEach((cell, index) => {
            const color = areaColors[index];
            const darkerColor = darkenColor(color, 40);
            cell.style.background = `linear-gradient(135deg, ${color}, ${darkerColor})`;
        });

        // Clean up all dot mixers (for edge cases like page visibility change)
        function cleanupAllDotMixers() {
            dotMixers.forEach((mixer, touchId) => {
                mixer.startFade();
            });
        }
        
        // Continuous update loop for mix percentages
        function updateAllDotMixers() {
            dotMixers.forEach((mixer) => {
                if (!mixer.isFading) {
                    mixer.updateMixPercentages();
                }
            });
        }
        
        // Start update loop (60fps)
        setInterval(updateAllDotMixers, 1000 / 60);

        // OLD HANDLERS REMOVED - Now using DotMixer system
        // Handle touch and mouse events (DEPRECATED - kept for reference)
        function handleStart_OLD(e, cell) {
            e.preventDefault();
            initAudio();
            
            if (!synth) return;

            const cellNum = parseInt(cell.dataset.cell);
            
            if (cellNum === 1) {
                // Area 1: Play chord on hold with position-based pitch and volume
                if (!isPlaying) {
                    // Get position relative to the cell
                    const rect = cell.getBoundingClientRect();
                    let x, y;
                    
                    if (e.touches && e.touches.length > 0) {
                        // Touch event
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                    } else {
                        // Mouse event
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    // Normalize to 0-1 (0 = left/top, 1 = right/bottom)
                    const normalizedX = Math.max(0, Math.min(1, x / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, y / rect.height));
                    
                    // X position: 0 (left) = quieter (0.2), 1 (right) = louder (1.0)
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    
                    // Y position: 0 (top) = +0.5 semitones, 1 (bottom) = -0.5 semitones
                    // Map from [0, 1] to [0.5, -0.5]
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    synth.playChord(pitchOffset, volumeMultiplier);
                    isPlaying = true;
                    cell.classList.add('active');
                }
            } else if (cellNum === 2) {
                // Area 2: Play bell on hold with position-based pitch and volume
                if (!isPlayingArea2) {
                    // Get position relative to the cell
                    const rect = cell.getBoundingClientRect();
                    let x, y;
                    
                    if (e.touches && e.touches.length > 0) {
                        // Touch event
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                    } else {
                        // Mouse event
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    // Normalize to 0-1 (0 = left/top, 1 = right/bottom)
                    const normalizedX = Math.max(0, Math.min(1, x / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, y / rect.height));
                    
                    // X position: 0 (left) = quieter (0.2), 1 (right) = louder (1.0)
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    
                    // Y position: 0 (top) = +0.5 semitones, 1 (bottom) = -0.5 semitones
                    // Map from [0, 1] to [0.5, -0.5]
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    synth.playBell(pitchOffset, volumeMultiplier);
                    isPlayingArea2 = true;
                    cell.classList.add('active');
                }
            } else if (cellNum === 3) {
                // Area 3: Play pad on hold with position-based pitch and volume
                if (!isPlayingArea3) {
                    // Get position relative to the cell
                    const rect = cell.getBoundingClientRect();
                    let x, y;
                    
                    if (e.touches && e.touches.length > 0) {
                        // Touch event
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                    } else {
                        // Mouse event
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    // Normalize to 0-1 (0 = left/top, 1 = right/bottom)
                    const normalizedX = Math.max(0, Math.min(1, x / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, y / rect.height));
                    
                    // X position: 0 (left) = quieter (0.2), 1 (right) = louder (1.0)
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    
                    // Y position: 0 (top) = +0.5 semitones, 1 (bottom) = -0.5 semitones
                    // Map from [0, 1] to [0.5, -0.5]
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    synth.playPad(pitchOffset, volumeMultiplier);
                    isPlayingArea3 = true;
                    cell.classList.add('active');
                }
            } else if (cellNum === 4) {
                // Area 4: Play brass/synth lead on hold with position-based pitch and volume
                if (!isPlayingArea4) {
                    // Get position relative to the cell
                    const rect = cell.getBoundingClientRect();
                    let x, y;
                    
                    if (e.touches && e.touches.length > 0) {
                        // Touch event
                        x = e.touches[0].clientX - rect.left;
                        y = e.touches[0].clientY - rect.top;
                    } else {
                        // Mouse event
                        x = e.clientX - rect.left;
                        y = e.clientY - rect.top;
                    }
                    
                    // Normalize to 0-1 (0 = left/top, 1 = right/bottom)
                    const normalizedX = Math.max(0, Math.min(1, x / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, y / rect.height));
                    
                    // X position: 0 (left) = quieter (0.2), 1 (right) = louder (1.0)
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    
                    // Y position: 0 (top) = +0.5 semitones, 1 (bottom) = -0.5 semitones
                    // Map from [0, 1] to [0.5, -0.5]
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    synth.playBrass(pitchOffset, volumeMultiplier);
                    isPlayingArea4 = true;
                    cell.classList.add('active');
                }
            }
        }

        function handleMove(e, cell) {
            e.preventDefault();
            
            if (!synth) return;

            const cellNum = parseInt(cell.dataset.cell);
            
            // Get position relative to the cell
            const rect = cell.getBoundingClientRect();
            let x, y;
            
            if (e.touches && e.touches.length > 0) {
                // Touch event
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                // Mouse event
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            // Normalize to 0-1 (0 = left/top, 1 = right/bottom)
            const normalizedX = Math.max(0, Math.min(1, x / rect.width));
            const normalizedY = Math.max(0, Math.min(1, y / rect.height));
            
            // X position: 0 (left) = quieter (0.2), 1 (right) = louder (1.0)
            const volumeMultiplier = 0.2 + (normalizedX * 0.8);
            
            // Y position: 0 (top) = +0.5 semitones, 1 (bottom) = -0.5 semitones
            // Map from [0, 1] to [0.5, -0.5]
            const pitchOffset = 0.5 - (normalizedY * 1.0);
            
            if (cellNum === 1 && isPlaying) {
                synth.updateChord(pitchOffset, volumeMultiplier);
            } else if (cellNum === 2 && isPlayingArea2) {
                synth.updateBell(pitchOffset, volumeMultiplier);
            } else if (cellNum === 3 && isPlayingArea3) {
                synth.updatePad(pitchOffset, volumeMultiplier);
            } else if (cellNum === 4 && isPlayingArea4) {
                synth.updateBrass(pitchOffset, volumeMultiplier);
            }
        }

        function handleEnd(e, cell) {
            e.preventDefault();
            
            if (!synth) return;

            const cellNum = parseInt(cell.dataset.cell);
            
            if (cellNum === 1) {
                // Area 1: Release chord
                if (isPlaying) {
                    synth.releaseChord();
                    isPlaying = false;
                    cell.classList.remove('active');
                }
            } else if (cellNum === 2) {
                // Area 2: Release bell
                if (isPlayingArea2) {
                    synth.releaseBell();
                    isPlayingArea2 = false;
                    cell.classList.remove('active');
                }
            } else if (cellNum === 3) {
                // Area 3: Release pad
                if (isPlayingArea3) {
                    synth.releasePad();
                    isPlayingArea3 = false;
                    cell.classList.remove('active');
                }
            } else if (cellNum === 4) {
                // Area 4: Release brass/synth lead
                if (isPlayingArea4) {
                    synth.releaseBrass();
                    isPlayingArea4 = false;
                    cell.classList.remove('active');
                }
            }
        }

        // Helper function to find cell from coordinates (more reliable than elementFromPoint)
        function findCellFromCoordinates(x, y) {
            const gridContainer = document.querySelector('.grid-container');
            if (!gridContainer) return null;
            
            const rect = gridContainer.getBoundingClientRect();
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            
            // Grid is 4x4
            const cellWidth = rect.width / 4;
            const cellHeight = rect.height / 4;
            
            const col = Math.floor(relativeX / cellWidth);
            const row = Math.floor(relativeY / cellHeight);
            
            // Validate bounds
            if (col < 0 || col >= 4 || row < 0 || row >= 4) return null;
            
            const cellIndex = row * 4 + col;
            return cells[cellIndex] || null;
        }

        // Multitouch-aware touch handlers
        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();
            
            if (!synth) return;
            
            // Process all touches in the event
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                // Find which cell this touch is in using coordinates
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                
                if (cell) {
                    // Limit to maximum 6 dots - remove oldest if at limit
                    const MAX_DOTS = 6;
                    if (dotMixers.size >= MAX_DOTS) {
                        // Remove the oldest dot mixer (first entry in Map)
                        const oldestTouchId = dotMixers.keys().next().value;
                        if (oldestTouchId !== undefined) {
                            const oldestMixer = dotMixers.get(oldestTouchId);
                            if (oldestMixer) {
                                oldestMixer.startFade();
                            }
                            dotMixers.delete(oldestTouchId);
                        }
                    }
                    
                    // Calculate normalized X position within the cell (0 = left, 1 = right)
                    const rect = cell.getBoundingClientRect();
                    const relativeX = touch.clientX - rect.left;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    
                    // Get the cell number to determine color
                    const cellNum = parseInt(cell.dataset.cell);
                    const areaColor = areaColors[cellNum - 1] || '#ffffff';
                    
                    // Create DotMixer for this touch
                    const mixer = new DotMixer(touchId, touch.clientX, touch.clientY, areaColor, normalizedX, cellNum, synth);
                    dotMixers.set(touchId, mixer);
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            // First, check for touches that are no longer active (orphaned dots)
            const activeTouchIds = new Set();
            for (let i = 0; i < e.touches.length; i++) {
                activeTouchIds.add(e.touches[i].identifier);
            }
            
            // Remove dot mixers for touches that are no longer in the active list
            dotMixers.forEach((mixer, touchId) => {
                if (!activeTouchIds.has(touchId)) {
                    // This touch is no longer active, start fade
                    mixer.startFade();
                    dotMixers.delete(touchId);
                }
            });
            
            // Process all active touches (not just changed ones) to update all dots
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchId = touch.identifier;
                
                const mixer = dotMixers.get(touchId);
                if (!mixer || mixer.isFading) continue;
                
                // Find which cell this touch is in using coordinates
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                
                // Update dot mixer position
                mixer.updatePosition(touch.clientX, touch.clientY, cell);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Process all touches in the event
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                const mixer = dotMixers.get(touchId);
                if (mixer) {
                    // Start fade (sounds will be released after fade completes)
                    mixer.startFade();
                    // Remove from map after fade starts (cleanup happens in startFade)
                    setTimeout(() => {
                        dotMixers.delete(touchId);
                    }, 2100); // Slightly after fade completes
                }
            }
        }

        // Mouse events for desktop (using touch simulation)
        cells.forEach(cell => {
            let mouseTouchId = null;
            
            cell.addEventListener('mousedown', (e) => {
                e.preventDefault();
                initAudio();
                if (!synth) return;
                
                // Create a fake touch ID for mouse
                mouseTouchId = 'mouse_' + Date.now();
                
                const cellNum = parseInt(cell.dataset.cell);
                const rect = cell.getBoundingClientRect();
                const relativeX = e.clientX - rect.left;
                const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                const areaColor = areaColors[cellNum - 1] || '#ffffff';
                
                // Limit to maximum 6 dots
                const MAX_DOTS = 6;
                if (dotMixers.size >= MAX_DOTS) {
                    const oldestTouchId = dotMixers.keys().next().value;
                    if (oldestTouchId !== undefined) {
                        const oldestMixer = dotMixers.get(oldestTouchId);
                        if (oldestMixer) {
                            oldestMixer.startFade();
                        }
                        dotMixers.delete(oldestTouchId);
                    }
                }
                
                const mixer = new DotMixer(mouseTouchId, e.clientX, e.clientY, areaColor, normalizedX, cellNum, synth);
                dotMixers.set(mouseTouchId, mixer);
            });
            
            cell.addEventListener('mousemove', (e) => {
                if (e.buttons === 1 && mouseTouchId) {
                    const mixer = dotMixers.get(mouseTouchId);
                    if (mixer && !mixer.isFading) {
                        const cell = findCellFromCoordinates(e.clientX, e.clientY);
                        mixer.updatePosition(e.clientX, e.clientY, cell);
                    }
                }
            });
            
            cell.addEventListener('mouseup', (e) => {
                if (mouseTouchId) {
                    const mixer = dotMixers.get(mouseTouchId);
                    if (mixer) {
                        mixer.startFade();
                        setTimeout(() => {
                            dotMixers.delete(mouseTouchId);
                        }, 2100);
                    }
                    mouseTouchId = null;
                }
            });
            
            cell.addEventListener('mouseleave', (e) => {
                if (mouseTouchId) {
                    const mixer = dotMixers.get(mouseTouchId);
                    if (mixer) {
                        mixer.startFade();
                        setTimeout(() => {
                            dotMixers.delete(mouseTouchId);
                        }, 2100);
                    }
                    mouseTouchId = null;
                }
            });
        });

        // Add global touch event listeners for multitouch support
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Cleanup on visibility change (when user switches tabs, etc.)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                cleanupAllDotMixers();
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanupAllDotMixers);

        // Periodic cleanup check (safety net - removes any orphaned dots)
        setInterval(() => {
            // Check if any dots are still in the DOM but not in our map
            const allDots = document.querySelectorAll('.touch-dot');
            allDots.forEach(dot => {
                let found = false;
                dotMixers.forEach((mixer) => {
                    if (mixer.dot === dot) {
                        found = true;
                    }
                });
                if (!found && dot.parentNode) {
                    dot.parentNode.removeChild(dot);
                }
            });
        }, 1000);
    </script>
</body>
</html>
