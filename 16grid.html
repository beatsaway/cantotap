<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Synth Grid Demo 3 - Multi-Touch Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            width: 100vw;
            height: 100vh;
            gap: 0;
        }

        .grid-cell {
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.1s;
        }

        .grid-cell:active,
        .grid-cell.active {
            background-color: rgba(100, 150, 255, 0.3);
        }

        .grid-cell.dragging-over {
            border: 2px solid white;
        }

        .grid-cell:nth-child(1) {
            background: linear-gradient(135deg, #2a4a6a, #1a2a3a);
        }

        .grid-cell:nth-child(2) {
            background: linear-gradient(135deg, #3a5a7a, #2a3a4a);
        }

        .grid-cell:nth-child(3) {
            background: linear-gradient(135deg, #4a6a8a, #3a4a5a);
        }

        .grid-cell:nth-child(4) {
            background: linear-gradient(135deg, #5a7a9a, #4a5a6a);
        }

        .grid-cell:nth-child(5) {
            background: linear-gradient(135deg, #6a8aaa, #5a6a7a);
        }

        .grid-cell:nth-child(6) {
            background: linear-gradient(135deg, #7a9aba, #6a7a8a);
        }

        .grid-cell:nth-child(7) {
            background: linear-gradient(135deg, #8aaaca, #7a8a9a);
        }

        .grid-cell:nth-child(8) {
            background: linear-gradient(135deg, #9abada, #8a9aaa);
        }

        .grid-cell:nth-child(9) {
            background: linear-gradient(135deg, #aacaea, #9aba9a);
        }

        .grid-cell:nth-child(10) {
            background: linear-gradient(135deg, #badafa, #aacaba);
        }

        .grid-cell:nth-child(11) {
            background: linear-gradient(135deg, #caeafa, #badaca);
        }

        .grid-cell:nth-child(12) {
            background: linear-gradient(135deg, #dafa0a, #ca0ada);
        }

        .grid-cell:nth-child(13) {
            background: linear-gradient(135deg, #ea0a1a, #da0a0a);
        }

        .grid-cell:nth-child(14) {
            background: linear-gradient(135deg, #fa1a2a, #ea1a1a);
        }

        .grid-cell:nth-child(15) {
            background: linear-gradient(135deg, #0a2a3a, #1a2a3a);
        }

        .grid-cell:nth-child(16) {
            background: linear-gradient(135deg, #1a3a4a, #2a3a4a);
        }

        /* Touch dot visualization */
        .touch-dot {
            position: fixed;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            pointer-events: none !important;
            z-index: 1000;
            transform: translate(-50%, -50%);
            transition: opacity 0.5s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            will-change: transform;
            opacity: 1;
        }

        /* Debug info for each dot */
        .dot-debug-info {
            position: fixed;
            font-size: 0.65rem;
            font-weight: normal;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 6px;
            border-radius: 4px;
            font-family: monospace;
            line-height: 1.2;
            pointer-events: none !important;
            z-index: 1001;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: pre;
            border: 1px solid rgba(255, 255, 255, 0.3);
            max-width: 150px;
        }

        /* Startup popup overlay */
        .startup-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .startup-popup.hidden {
            display: none;
        }

        .startup-popup-content {
            background: linear-gradient(135deg, #2a4a6a, #1a2a3a);
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
        }

        .startup-popup-content h1 {
            color: #fff;
            font-size: 2rem;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .startup-popup-content p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1rem;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        .start-button {
            background: linear-gradient(135deg, #4ecdc4, #3a9a8a);
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }

        .start-button:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <!-- Startup popup -->
    <div class="startup-popup" id="startup-popup">
        <div class="startup-popup-content">
            <h1>Water Synth Grid</h1>
            <p>Touch and drag across the grid to create sounds.<br>Multi-touch supported!</p>
            <button class="start-button" id="start-button">Start Audio</button>
        </div>
    </div>

    <div class="grid-container">
        <div class="grid-cell" data-cell="1">Area 1<br>Chord</div>
        <div class="grid-cell" data-cell="2">Area 2</div>
        <div class="grid-cell" data-cell="3">Area 3</div>
        <div class="grid-cell" data-cell="4">Area 4</div>
        <div class="grid-cell" data-cell="5">Area 5</div>
        <div class="grid-cell" data-cell="6">Area 6</div>
        <div class="grid-cell" data-cell="7">Area 7</div>
        <div class="grid-cell" data-cell="8">Area 8</div>
        <div class="grid-cell" data-cell="9">Area 9</div>
        <div class="grid-cell" data-cell="10">Area 10</div>
        <div class="grid-cell" data-cell="11">Area 11</div>
        <div class="grid-cell" data-cell="12">Area 12</div>
        <div class="grid-cell" data-cell="13">Area 13</div>
        <div class="grid-cell" data-cell="14">Area 14</div>
        <div class="grid-cell" data-cell="15">Area 15</div>
        <div class="grid-cell" data-cell="16">Area 16</div>
    </div>

    <script>
        /*
         * ORPHAN PREVENTION STRATEGIES:
         * 
         * 1. HEARTBEAT MECHANISM: Each DotMixer tracks last activity time.
         *    If no activity for 2+ seconds, automatically fades out.
         * 
         * 2. GLOBAL TOUCH TRACKER: Maintains a Set of all active touches.
         *    Compares against browser's touch list to detect orphans.
         * 
         * 3. ABORT CONTROLLER: Coordinates cleanup operations to prevent race conditions.
         * 
         * 4. AGGRESSIVE CLEANUP: Multiple cleanup strategies run every 500ms.
         * 
         * 5. ACTIVITY TRACKING: All position updates mark activity timestamp.
         * 
         * RECOMMENDED LIBRARIES (if issues persist):
         * 
         * - Hammer.js (https://hammerjs.github.io/): More reliable touch event handling
         *   Handles edge cases like lost touches, gesture recognition, etc.
         * 
         * - Interact.js (https://interactjs.io/): Advanced drag/drop with better cleanup
         *   Better for complex interactions but might be overkill
         * 
         * - Pointer Events Polyfill: For better cross-browser touch support
         *   Helps with inconsistent touch event behavior across browsers
         */
       
        class WaterSynthTone {
            constructor() {
                // Create reverb with very wet signal (like original: 1.0 reverb, 0.3 dry)
                this.reverb = new Tone.Reverb({
                    roomSize: 0.9,
                    dampening: 3000,
                    wet: 0.77  // Very wet reverb (1.0 / (1.0 + 0.3))
                }).toDestination();

                // Create compressor/limiter
                this.compressor = new Tone.Compressor({
                    threshold: -12,
                    ratio: 12,
                    attack: 0.003,
                    release: 0.1
                }).connect(this.reverb);

                // Create EQ for natural rolloff (for area 2/bell sounds)
                this.eq = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 15000,
                    Q: 0.7
                }).connect(this.compressor);

                // Master gain - split into dry and wet paths
                this.masterGain = new Tone.Gain(1.0);
                this.dryGain = new Tone.Gain(0.3).connect(this.eq);  // Less dry signal (for bell/area 2)
                this.reverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Very loud reverb
                
                // Separate path for area 1 (water sounds) - bypasses filter
                this.area1DryGain = new Tone.Gain(0.3).connect(this.compressor);  // Direct to compressor, no filter
                this.area1ReverbGain = new Tone.Gain(1.0).connect(this.reverb);  // Reverb path
                
                // Connect master to both paths (for bell/area 2)
                this.masterGain.connect(this.dryGain);
                this.masterGain.connect(this.reverbGain);
                
                // Separate master gain for area 1 (no filter)
                this.masterGainArea1 = new Tone.Gain(1.0);
                this.masterGainArea1.connect(this.area1DryGain);
                this.masterGainArea1.connect(this.area1ReverbGain);

                // Generate reverb impulse response
                this.reverb.generate().catch(console.error);
            }

            // Create a water-like sound with pitch drop and noise
            createWaterVoice(frequency, pitchDrop = 0.02, noiseAmount = 0.03, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                // Add natural variation (like original)
                const finalPitchDrop = frequency * (pitchDrop + Math.random() * 0.02);
                const finalNoiseAmount = noiseAmount * (0.8 + Math.random() * 0.4);

                // Apply pitch offset (in semitones, converted to frequency ratio)
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;

                // Main oscillator with pitch drop on attack
                const osc = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency + finalPitchDrop
                });

                // Frequency envelope for pitch drop - exponential ramp
                osc.frequency.exponentialRampTo(adjustedFrequency, 0.08);

                // Add harmonic oscillators
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 2) + (finalPitchDrop * 2)
                });
                osc2.frequency.exponentialRampTo(adjustedFrequency * 2, 0.08);
                
                const osc3 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 3) + (finalPitchDrop * 3)
                });
                osc3.frequency.exponentialRampTo(adjustedFrequency * 3, 0.08);
                
                const osc4 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: (adjustedFrequency * 4) + (finalPitchDrop * 4)
                });
                osc4.frequency.exponentialRampTo(adjustedFrequency * 4, 0.08);

                // Amplitude envelopes
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.35,
                    release: 0.2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.25,
                    release: 0.2
                });
                
                const env3 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.15,
                    release: 0.2
                });
                
                const env4 = new Tone.AmplitudeEnvelope({
                    attack: 0.02,
                    decay: 0.01,
                    sustain: 0.1,
                    release: 0.2
                });
                
                const harmonicGain2 = new Tone.Gain(0.3);
                const harmonicGain3 = new Tone.Gain(0.2);
                const harmonicGain4 = new Tone.Gain(0.1);

                // Noise component
                const noise = new Tone.Noise({
                    type: 'white',
                    volume: -20
                });

                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 0.07,
                    sustain: 0,
                    release: 0.2
                });

                const noiseGain = new Tone.Gain();
                noiseGain.gain.value = finalNoiseAmount * 0.5;

                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);

                // Connect oscillators
                osc.connect(env);
                env.connect(volumeGain);
                
                osc2.connect(env2);
                env2.connect(harmonicGain2);
                harmonicGain2.connect(volumeGain);
                
                osc3.connect(env3);
                env3.connect(harmonicGain3);
                harmonicGain3.connect(volumeGain);
                
                osc4.connect(env4);
                env4.connect(harmonicGain4);
                harmonicGain4.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGainArea1);

                noise.connect(noiseGain);
                noiseGain.connect(noiseEnv);
                noiseEnv.connect(pan);

                // Start
                osc.start(now);
                osc2.start(now);
                osc3.start(now);
                osc4.start(now);
                noise.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                env3.triggerAttack(now);
                env4.triggerAttack(now);
                noiseEnv.triggerAttack(now);

                noise.stop(now + 0.15);

                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    oscillator3: osc3,
                    oscillator4: osc4,
                    envelope: env,
                    envelope2: env2,
                    envelope3: env3,
                    envelope4: env4,
                    noise: noise,
                    noiseEnv: noiseEnv,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        env3.triggerRelease();
                        env4.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                        osc3.stop('+0.5');
                        osc4.stop('+0.5');
                        noise.stop();
                    }
                };
            }

            // Create area 1 voices connected to a given gain node (for DotMixer)
            createArea1Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createWaterVoice(freq, 0.02, 0.03, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a bell/chime sound
            createBellVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'triangle',
                    frequency: adjustedFrequency
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 2.0,
                    sustain: 0.35,  // Increased from 0.1 to match area 1's sustain level
                    release: 0.2
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'sine',
                    frequency: adjustedFrequency * 2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.01,
                    decay: 1.5,
                    sustain: 0.25,  // Increased from 0.05 to better match other areas
                    release: 0.2
                });
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);
                
                osc.connect(env);
                env.connect(volumeGain);
                osc2.connect(env2);
                env2.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Create area 2 voices
            createArea2Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createBellVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a pad/string-like sound
            createPadVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.3,
                    decay: 0.2,
                    sustain: 0.4,  // Reduced from 0.7 to match area 1/2 loudness
                    release: 0.2
                });
                
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 2000,
                    Q: 1.0
                });
                
                filter.frequency.setValueAtTime(2000, now);
                filter.frequency.exponentialRampTo(16000, now + 0.4);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                env.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    envelope: env,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        osc.stop('+1.0');
                    }
                };
            }

            // Create area 3 voices
            createArea3Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createPadVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }

            // Create a brass/synth lead sound
            createLeadVoice(frequency, pitchOffset = 0, volumeMultiplier = 1.0, outputNode = null) {
                const now = Tone.now();
                
                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                const adjustedFrequency = frequency * pitchMultiplier;
                
                const osc = new Tone.Oscillator({
                    type: 'sawtooth',
                    frequency: adjustedFrequency
                });
                
                const osc2 = new Tone.Oscillator({
                    type: 'square',
                    frequency: adjustedFrequency * 0.5
                });
                
                const env = new Tone.AmplitudeEnvelope({
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.4,  // Reduced from 0.85 to match area 1/2 loudness
                    release: 0.2
                });
                
                const env2 = new Tone.AmplitudeEnvelope({
                    attack: 0.05,
                    decay: 0.1,
                    sustain: 0.3,  // Reduced from 0.7 to better match other areas
                    release: 0.2
                });
                
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 3000,
                    Q: 1.0
                });
                
                filter.frequency.setValueAtTime(3000, now);
                filter.frequency.exponentialRampTo(12000, now + 0.1);
                
                const pan = new Tone.Panner((Math.random() - 0.5) * 0.15);
                const volumeGain = new Tone.Gain(volumeMultiplier * 1.5);
                const osc2Gain = new Tone.Gain(0.4);
                
                osc.connect(filter);
                filter.connect(env);
                env.connect(volumeGain);
                
                osc2.connect(env2);
                env2.connect(osc2Gain);
                osc2Gain.connect(volumeGain);
                
                volumeGain.connect(pan);
                pan.connect(outputNode || this.masterGain);
                
                osc.start(now);
                osc2.start(now);
                env.triggerAttack(now);
                env2.triggerAttack(now);
                
                return {
                    oscillator: osc,
                    oscillator2: osc2,
                    envelope: env,
                    envelope2: env2,
                    filter: filter,
                    pan: pan,
                    volumeGain: volumeGain,
                    stop: () => {
                        env.triggerRelease();
                        env2.triggerRelease();
                        osc.stop('+0.5');
                        osc2.stop('+0.5');
                    }
                };
            }

            // Create area 4 voices
            createArea4Voices(pitchOffset, volumeMultiplier, outputGain) {
                const chordFrequencies = [261.63, 329.63, 392.00];
                return chordFrequencies.map(freq => 
                    this.createLeadVoice(freq, pitchOffset, volumeMultiplier, outputGain)
                );
            }
        }

        // DotMixer class - manages a dot and its sound mixing with demoold.html's crossfade mechanism
        class DotMixer {
            constructor(touchId, x, y, initialArea, synth) {
                this.touchId = touchId;
                this.synth = synth;
                
                // Create visual dot
                this.dot = this.createVisualDot(x, y, initialArea);
                
                // Track area sounds: { areaNum: { voices: [...], mixGain: Tone.Gain, mixPercent: number } }
                this.areaSounds = new Map();
                
                // Master gain for this dot's mixed output
                this.masterGain = new Tone.Gain(1.0);
                this.masterGain.toDestination();
                
                // Current position
                this.currentX = x;
                this.currentY = y;
                this.currentCell = initialArea;
                
                // Crossfade constants (matching demoold.html)
                this.CROSSFADE_DURATION = 3.0; // seconds
                this.MIXRATIO_RATE = 100.0 / this.CROSSFADE_DURATION; // 33.33% per second
                this.lastUpdateTime = performance.now();
                
                // Track active areas and mix ratios (per dot)
                // Note: Mix ratios are tracked by area TYPE (1-4), not area number (1-16)
                // This allows crossfading between sound types when moving between areas
                this.areaMixRatios = { 1: 0, 2: 0, 3: 0, 4: 0 };
                this.areaMixDirections = { 1: 'none', 2: 'none', 3: 'none', 4: 'none' };
                this.activeAreas = new Set(); // Tracks area numbers (1-16) that have sounds
                
                // Performance: Limit active areas per dot to prevent too many voices
                this.MAX_AREAS_PER_DOT = 3; // Only keep 3 most recent areas active
                this.areaHistory = []; // Track order of areas added
                this.lastDebugUpdate = 0; // Track last debug display update for throttling
                
                // Start sound for initial area
                this.addAreaSound(initialArea);
                
                // Track if fading
                this.isFading = false;
                
                // HEARTBEAT MECHANISM: Track last activity to detect stale touches
                this.lastActivityTime = performance.now();
                this.heartbeatInterval = null;
                
                // ABORT CONTROLLER: For coordinated cleanup
                this.abortController = new AbortController();
                
                // Setup heartbeat check (detects stale touches that never got touchend)
                this.setupHeartbeat();
            }
            
            // Setup heartbeat to detect stale touches
            setupHeartbeat() {
                // Check every 500ms if touch is stale (no activity for 2 seconds)
                this.heartbeatInterval = setInterval(() => {
                    const now = performance.now();
                    const timeSinceActivity = now - this.lastActivityTime;
                    
                    // If no activity for 2 seconds and not already fading, consider it stale
                    if (timeSinceActivity > 2000 && !this.isFading) {
                        console.warn(`Stale touch detected: ${this.touchId} (${timeSinceActivity.toFixed(0)}ms inactive)`);
                        this.startFade();
                    }
                }, 500);
            }
            
            // Update activity timestamp
            markActivity() {
                this.lastActivityTime = performance.now();
            }
            
            createVisualDot(x, y, areaNum) {
                const dot = document.createElement('div');
                dot.className = 'touch-dot';
                
                // Color based on area (matching demoold.html's gradient colors)
                const colors = {
                    1: '#2a4a6a', 2: '#3a5a7a', 3: '#4a6a8a', 4: '#5a7a9a',
                    5: '#6a8aaa', 6: '#7a9aba', 7: '#8aaaca', 8: '#9abada',
                    9: '#aacaea', 10: '#badafa', 11: '#caeafa', 12: '#dafa0a',
                    13: '#ea0a1a', 14: '#fa1a2a', 15: '#0a2a3a', 16: '#1a3a4a'
                };
                dot.style.backgroundColor = colors[areaNum] || '#ffffff';
                
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                
                // Size based on X position
                const cell = cells[areaNum - 1];
                if (cell) {
                    const rect = cell.getBoundingClientRect();
                    const relativeX = x - rect.left;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    const minSize = 20;
                    const maxSize = 40;
                    const size = minSize + (normalizedX * (maxSize - minSize));
                    dot.style.width = size + 'px';
                    dot.style.height = size + 'px';
                }
                
                // Create debug info element
                const debugInfo = document.createElement('div');
                debugInfo.className = 'dot-debug-info';
                debugInfo.id = `dot-debug-${this.touchId}`;
                debugInfo.textContent = 'Vol: 0%\nMix: 0%';
                debugInfo.style.left = x + 'px';
                debugInfo.style.top = y + 'px';
                
                document.body.appendChild(dot);
                document.body.appendChild(debugInfo);
                
                // Store reverse lookup: dot -> mixer (for finding mixers from orphaned dots)
                dotToMixerMap.set(dot, this);
                dotToMixerMap.set(debugInfo, this);
                
                this.debugInfo = debugInfo;
                return dot;
            }
            
            // Add or update area sound
            addAreaSound(areaNum) {
                if (this.areaSounds.has(areaNum)) {
                    return; // Already exists
                }
                
                // Performance: Check global voice limit before creating new voices
                const currentTotalVoices = countTotalActiveVoices();
                const voicesPerArea = 3; // Each area has 3 voices (chord)
                
                // If we're at the limit, clean up oldest inactive areas first
                if (currentTotalVoices + voicesPerArea > MAX_TOTAL_VOICES) {
                    // Clean up areas with mix < 5% that aren't current
                    const areasToClean = [];
                    this.areaSounds.forEach((soundData, num) => {
                        const areaType = ((num - 1) % 4) + 1;
                        const mix = this.areaMixRatios[areaType];
                        if (mix < 5 && num !== this.currentCell) {
                            areasToClean.push(num);
                        }
                    });
                    // Clean up oldest first
                    areasToClean.sort((a, b) => {
                        const idxA = this.areaHistory.indexOf(a);
                        const idxB = this.areaHistory.indexOf(b);
                        return idxA - idxB;
                    });
                    areasToClean.slice(0, 2).forEach(num => {
                        this.cleanupAreaSound(num);
                    });
                }
                
                // Performance: Limit areas per dot - remove oldest if at limit
                if (this.areaSounds.size >= this.MAX_AREAS_PER_DOT) {
                    // Find oldest area that's not current
                    const oldestArea = this.areaHistory.find(num => 
                        num !== this.currentCell && this.areaSounds.has(num)
                    );
                    if (oldestArea) {
                        this.cleanupAreaSound(oldestArea);
                    }
                }
                
                // Create mix gain for this area
                const mixGain = new Tone.Gain(0); // Start at 0, will transition
                mixGain.connect(this.masterGain);
                
                // Get pitch and volume from position
                const cell = cells[areaNum - 1];
                if (!cell) return;
                
                const rect = cell.getBoundingClientRect();
                const relativeX = this.currentX - rect.left;
                const relativeY = this.currentY - rect.top;
                const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                const normalizedY = Math.max(0, Math.min(1, relativeY / rect.height));
                
                const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                const pitchOffset = 0.5 - (normalizedY * 1.0);
                
                // Create voices based on area type
                let voices = [];
                const areaType = ((areaNum - 1) % 4) + 1;
                if (areaType === 1) {
                    voices = this.synth.createArea1Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaType === 2) {
                    voices = this.synth.createArea2Voices(pitchOffset, volumeMultiplier, mixGain);
                } else if (areaType === 3) {
                    voices = this.synth.createArea3Voices(pitchOffset, volumeMultiplier, mixGain);
                } else {
                    voices = this.synth.createArea4Voices(pitchOffset, volumeMultiplier, mixGain);
                }
                
                this.areaSounds.set(areaNum, {
                    voices: voices,
                    mixGain: mixGain,
                    mixPercent: 0,
                    pitchOffset: pitchOffset,
                    volumeMultiplier: volumeMultiplier
                });
                
                // Track in history
                this.areaHistory.push(areaNum);
                // Keep history limited
                if (this.areaHistory.length > 10) {
                    this.areaHistory.shift();
                }
                
                // If this is the current cell, set mix to 100% for this area type
                if (areaNum === this.currentCell) {
                    const areaType = ((areaNum - 1) % 4) + 1;
                    this.areaMixRatios[areaType] = 100;
                    this.areaMixDirections[areaType] = 'none';
                    this.activeAreas.add(areaNum);
                    mixGain.gain.rampTo(1.0, 0.05);
                    
                    // Update debug display with initial values
                    const initialVol = volumeMultiplier * 100;
                    this.updateDebugDisplay([{
                        areaNum: areaNum,
                        areaType: areaType,
                        vol: initialVol,
                        mix: 100,
                        isCurrent: true
                    }], areaNum);
                }
            }
            
            // Update position and handle area transitions
            updatePosition(x, y, cell) {
                // Mark activity for heartbeat
                this.markActivity();
                
                this.currentX = x;
                this.currentY = y;
                
                // Update dot visual position
                this.dot.style.left = x + 'px';
                this.dot.style.top = y + 'px';
                
                // Update debug info position
                if (this.debugInfo) {
                    this.debugInfo.style.left = x + 'px';
                    this.debugInfo.style.top = y + 'px';
                }
                
                if (cell) {
                    const cellNum = parseInt(cell.dataset.cell);
                    const rect = cell.getBoundingClientRect();
                    const relativeX = x - rect.left;
                    const relativeY = y - rect.top;
                    const normalizedX = Math.max(0, Math.min(1, relativeX / rect.width));
                    const normalizedY = Math.max(0, Math.min(1, relativeY / rect.height));
                    
                    // Update size
                    const minSize = 20;
                    const maxSize = 40;
                    const size = minSize + (normalizedX * (maxSize - minSize));
                    this.dot.style.width = size + 'px';
                    this.dot.style.height = size + 'px';
                    
                    // Update pitch and volume for current area
                    const volumeMultiplier = 0.2 + (normalizedX * 0.8);
                    const pitchOffset = 0.5 - (normalizedY * 1.0);
                    
                    // Check if we're in a new area
                    if (cellNum !== this.currentCell) {
                        const oldCell = this.currentCell;
                        this.currentCell = cellNum;
                        
                        // Add new area sound if needed
                        if (!this.areaSounds.has(cellNum)) {
                            this.addAreaSound(cellNum);
                        }
                        
                        // Update mix directions for crossfade (by area type, not area number)
                        const oldAreaType = oldCell ? ((oldCell - 1) % 4) + 1 : 0;
                        const newAreaType = ((cellNum - 1) % 4) + 1;
                        
                        if (oldAreaType > 0 && oldAreaType !== newAreaType) {
                            this.areaMixDirections[oldAreaType] = 'down';
                        }
                        this.areaMixDirections[newAreaType] = 'up';
                        this.activeAreas.add(cellNum);
                    }
                    
                    // Update pitch and volume for current area's voices
                    const currentSound = this.areaSounds.get(cellNum);
                    if (currentSound) {
                        currentSound.pitchOffset = pitchOffset;
                        currentSound.volumeMultiplier = volumeMultiplier;
                        
                        // Update each voice
                        currentSound.voices.forEach((voice, index) => {
                            if (voice && voice.oscillator && voice.volumeGain) {
                                const baseFrequencies = [261.63, 329.63, 392.00];
                                const baseFreq = baseFrequencies[index];
                                const pitchMultiplier = Math.pow(2, pitchOffset / 12);
                                const newFrequency = baseFreq * pitchMultiplier;
                                
                                voice.oscillator.frequency.rampTo(newFrequency, 0.05);
                                
                                if (voice.oscillator2) {
                                    voice.oscillator2.frequency.rampTo(newFrequency * 2, 0.05);
                                }
                                if (voice.oscillator3) {
                                    voice.oscillator3.frequency.rampTo(newFrequency * 3, 0.05);
                                }
                                if (voice.oscillator4) {
                                    voice.oscillator4.frequency.rampTo(newFrequency * 4, 0.05);
                                }
                                
                                // Update volume (account for area 4's 1.5x boost)
                                const vol = (cellNum % 4 === 0) ? volumeMultiplier * 1.5 : volumeMultiplier;
                                voice.volumeGain.gain.rampTo(vol, 0.05);
                            }
                        });
                    }
                }
                
                // Update mix percentages
                this.updateMixPercentages();
            }
            
            // Update mix percentages towards targets (matching demoold.html's mechanism)
            updateMixPercentages() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = currentTime;
                
                const clampedDeltaTime = Math.max(0.001, Math.min(deltaTime, 0.1));
                const changePerFrame = this.MIXRATIO_RATE * clampedDeltaTime;
                
                // Get current area type (1-4)
                const currentAreaType = this.currentCell ? ((this.currentCell - 1) % 4) + 1 : 0;
                
                // Update directions based on current area type
                for (let areaType = 1; areaType <= 4; areaType++) {
                    // Check if any area with this type has sound
                    let hasSoundOfType = false;
                    this.areaSounds.forEach((soundData, areaNum) => {
                        const areaTypeForArea = ((areaNum - 1) % 4) + 1;
                        if (areaTypeForArea === areaType) {
                            hasSoundOfType = true;
                        }
                    });
                    
                    const isCurrentType = (areaType === currentAreaType);
                    
                    if (isCurrentType && hasSoundOfType) {
                        if (this.areaMixRatios[areaType] < 100) {
                            this.areaMixDirections[areaType] = 'up';
                        } else {
                            this.areaMixDirections[areaType] = 'none';
                        }
                    } else if (hasSoundOfType) {
                        if (this.areaMixRatios[areaType] > 0) {
                            this.areaMixDirections[areaType] = 'down';
                        } else {
                            this.areaMixDirections[areaType] = 'none';
                        }
                    }
                }
                
                // Update mix ratios by area type (1-4)
                for (let areaType = 1; areaType <= 4; areaType++) {
                    const direction = this.areaMixDirections[areaType] || 'none';
                    let newMix = this.areaMixRatios[areaType];
                    
                    if (direction === 'up') {
                        newMix = Math.min(100, newMix + changePerFrame);
                    } else if (direction === 'down') {
                        newMix = Math.max(0, newMix - changePerFrame);
                    }
                    
                    this.areaMixRatios[areaType] = newMix;
                    
                    // Apply this mix ratio to all areas of this type
                    this.areaSounds.forEach((soundData, areaNum) => {
                        const areaTypeForArea = ((areaNum - 1) % 4) + 1;
                        if (areaTypeForArea === areaType) {
                            soundData.mixPercent = newMix;
                            // Update gain (convert percentage to 0-1 range)
                            soundData.mixGain.gain.rampTo(newMix / 100, 0.05);
                        }
                    });
                }
                
                // Collect all active areas with their volumes and mix percentages
                const activeAreaInfo = [];
                
                this.areaSounds.forEach((soundData, areaNum) => {
                    const areaType = ((areaNum - 1) % 4) + 1;
                    const mix = this.areaMixRatios[areaType];
                    
                    // Calculate volume for this area (only if mix > 0)
                    if (mix > 0.1) {
                        // Performance: Simplified volume calculation (cache mixGain value)
                        const mixVol = mix / 100;
                        const baseVol = soundData.volumeMultiplier || 0;
                        const maxVolume = baseVol * mixVol; // Simplified calculation
                        
                        const isCurrentArea = (areaNum === this.currentCell);
                        activeAreaInfo.push({
                            areaNum: areaNum,
                            areaType: areaType,
                            vol: maxVolume * 100, // Convert to percentage
                            mix: mix,
                            isCurrent: isCurrentArea
                        });
                    }
                    
                    // Cleanup if mix reaches 0 (more aggressive cleanup for performance)
                    if (mix <= 0.1 && !this.activeAreas.has(areaNum)) {
                        // Immediate cleanup - don't wait
                        this.cleanupAreaSound(areaNum);
                    } else if (mix < 5 && !this.activeAreas.has(areaNum) && countTotalActiveVoices() > MAX_TOTAL_VOICES * 0.8) {
                        // Aggressive cleanup when approaching voice limit
                        this.cleanupAreaSound(areaNum);
                    }
                });
                
                // Sort by area number for consistent display
                activeAreaInfo.sort((a, b) => a.areaNum - b.areaNum);
                
                // Update debug display with all active areas (throttled for performance)
                if (!this.lastDebugUpdate || (currentTime - this.lastDebugUpdate) > 100) {
                    // Only update debug display every 100ms
                    this.updateDebugDisplay(activeAreaInfo, this.currentCell);
                    this.lastDebugUpdate = currentTime;
                }
            }
            
            // Update debug display for this dot - show all active areas
            updateDebugDisplay(activeAreaInfo, currentCell) {
                if (!this.debugInfo) return;
                
                if (activeAreaInfo.length === 0) {
                    this.debugInfo.textContent = `Area: ${currentCell || '?'}\nNo active sounds`;
                    return;
                }
                
                // Build display text
                let text = `Area: ${currentCell || '?'}\n`;
                
                activeAreaInfo.forEach((info, index) => {
                    const marker = info.isCurrent ? 'â†’' : ' ';
                    text += `${marker}A${info.areaNum}: Vol${info.vol.toFixed(0)}% Mix${info.mix.toFixed(0)}%\n`;
                });
                
                // Remove trailing newline
                text = text.trim();
                
                this.debugInfo.textContent = text;
            }
            
            cleanupAreaSound(areaNum) {
                const soundData = this.areaSounds.get(areaNum);
                if (!soundData) return;
                
                // Immediately stop and dispose all voices (more aggressive cleanup)
                soundData.voices.forEach(voice => {
                    if (voice) {
                        // Stop oscillators immediately
                        try {
                            if (voice.oscillator) voice.oscillator.stop();
                            if (voice.oscillator2) voice.oscillator2.stop();
                            if (voice.oscillator3) voice.oscillator3.stop();
                            if (voice.oscillator4) voice.oscillator4.stop();
                            if (voice.noise) voice.noise.stop();
                        } catch (e) {
                            // Ignore errors if already stopped
                        }
                        // Dispose nodes immediately
                        try {
                            if (voice.oscillator) voice.oscillator.dispose();
                            if (voice.oscillator2) voice.oscillator2.dispose();
                            if (voice.oscillator3) voice.oscillator3.dispose();
                            if (voice.oscillator4) voice.oscillator4.dispose();
                            if (voice.envelope) voice.envelope.dispose();
                            if (voice.envelope2) voice.envelope2.dispose();
                            if (voice.envelope3) voice.envelope3.dispose();
                            if (voice.envelope4) voice.envelope4.dispose();
                            if (voice.noise) voice.noise.dispose();
                            if (voice.noiseEnv) voice.noiseEnv.dispose();
                            if (voice.pan) voice.pan.dispose();
                            if (voice.volumeGain) voice.volumeGain.dispose();
                            if (voice.filter) voice.filter.dispose();
                        } catch (e) {
                            // Ignore disposal errors
                        }
                    }
                });
                
                // Dispose gain immediately
                try {
                    soundData.mixGain.disconnect();
                    soundData.mixGain.dispose();
                } catch (e) {
                    // Ignore disposal errors
                }
                
                this.areaSounds.delete(areaNum);
                // Remove from history
                const historyIdx = this.areaHistory.indexOf(areaNum);
                if (historyIdx >= 0) {
                    this.areaHistory.splice(historyIdx, 1);
                }
                // Note: Don't reset areaMixRatios here - they're shared by area type
                // They'll be reset naturally when all areas of that type are cleaned up
            }
            
            // Start fade and release sounds
            startFade() {
                if (this.isFading) return;
                this.isFading = true;
                
                // Abort any pending operations
                this.abortController.abort();
                
                // Clear heartbeat interval
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                
                // Track fade start time for safety cleanup
                this.fadeStartTime = performance.now();
                
                // Store timeout ID for cleanup
                this.fadeTimeoutId = null;
                
                // Release all sounds using ADSR release (matching demoold.html)
                this.areaSounds.forEach((soundData, areaNum) => {
                    soundData.voices.forEach(voice => {
                        if (voice) {
                            if (voice.envelope) voice.envelope.triggerRelease();
                            if (voice.envelope2) voice.envelope2.triggerRelease();
                            if (voice.envelope3) voice.envelope3.triggerRelease();
                            if (voice.envelope4) voice.envelope4.triggerRelease();
                            if (voice.noiseEnv) voice.noiseEnv.triggerRelease();
                        }
                    });
                });
                
                // Start visual fade (faster fade - 0.5s instead of 2s)
                this.dot.style.transition = 'opacity 0.5s ease-out';
                this.dot.style.opacity = '0';
                
                // Cleanup after fade (reduced to 0.6s to match visual fade)
                this.fadeTimeoutId = setTimeout(() => {
                    this.cleanupCompletely();
                }, 600);
            }
            
            // Complete cleanup - remove dot and all sounds
            cleanupCompletely() {
                // Abort any pending operations
                this.abortController.abort();
                
                // Clear timeout if it exists
                if (this.fadeTimeoutId) {
                    clearTimeout(this.fadeTimeoutId);
                    this.fadeTimeoutId = null;
                }
                
                // Clear heartbeat interval
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                
                // CRITICAL: Cleanup all area sounds FIRST (before removing visual elements)
                // This ensures sounds are always stopped when dots are removed
                this.areaSounds.forEach((soundData, areaNum) => {
                    this.cleanupAreaSound(areaNum);
                });
                
                // Remove reverse lookup mappings
                if (this.dot) {
                    dotToMixerMap.delete(this.dot);
                }
                if (this.debugInfo) {
                    dotToMixerMap.delete(this.debugInfo);
                }
                
                // Remove visual elements immediately
                if (this.dot && this.dot.parentNode) {
                    this.dot.parentNode.removeChild(this.dot);
                }
                if (this.debugInfo && this.debugInfo.parentNode) {
                    this.debugInfo.parentNode.removeChild(this.debugInfo);
                }
                
                // Dispose master gain
                try {
                    this.masterGain.disconnect();
                    this.masterGain.dispose();
                } catch (e) {
                    // Ignore disposal errors
                }
            }
        }

        // Initialize synth
        let synth = null;
        let audioInitialized = false;

        // Initialize audio context - only called from start button
        function initAudio() {
            if (audioInitialized) return;
            
            Tone.start().then(() => {
                synth = new WaterSynthTone();
                audioInitialized = true;
                console.log('Audio initialized');
                
                // Hide the startup popup
                const popup = document.getElementById('startup-popup');
                if (popup) {
                    popup.classList.add('hidden');
                }
            }).catch((error) => {
                console.error('Failed to initialize audio:', error);
                alert('Failed to initialize audio. Please try again.');
            });
        }

        // Setup start button
        const startButton = document.getElementById('start-button');
        if (startButton) {
            startButton.addEventListener('click', () => {
                initAudio();
            });
        }

        // Get all grid cells
        const cells = document.querySelectorAll('.grid-cell');

        // Multitouch tracking - using DotMixer instances
        const dotMixers = new Map(); // Map of touchId -> DotMixer instance
        const dotToMixerMap = new WeakMap(); // Map of dot element -> DotMixer (for finding mixers from orphaned dots)
        
        // GLOBAL TOUCH TRACKER: Track all active touches from browser
        // This helps detect when browser loses track of touches
        const globalActiveTouches = new Set(); // Set of touch identifiers currently active
        
        // Performance optimization: Limit total active voices globally
        const MAX_TOTAL_VOICES = 150; // Limit total voices across all dots (6 dots * ~25 voices each)
        
        // Track total active voices
        function countTotalActiveVoices() {
            let total = 0;
            dotMixers.forEach((mixer) => {
                mixer.areaSounds.forEach((soundData) => {
                    total += soundData.voices.length;
                });
            });
            return total;
        }
        
        // GLOBAL CLEANUP: Force cleanup all orphaned mixers
        function forceCleanupOrphanedMixers() {
            // Get all currently active touches from browser
            const browserActiveTouches = new Set();
            
            // We'll update this in touchmove/touchend handlers
            // For now, check against our global tracker
            
            // Cleanup any mixers whose touches are no longer in browser's active list
            dotMixers.forEach((mixer, touchId) => {
                // If touch is not in global tracker and not fading, it's orphaned
                if (!globalActiveTouches.has(touchId) && !mixer.isFading) {
                    console.warn(`Force cleaning orphaned mixer: ${touchId}`);
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(touchId);
                    }, 700);
                }
            });
        }

        // Helper function to find cell from coordinates
        function findCellFromCoordinates(x, y) {
            const gridContainer = document.querySelector('.grid-container');
            if (!gridContainer) return null;
            
            const rect = gridContainer.getBoundingClientRect();
            const relativeX = x - rect.left;
            const relativeY = y - rect.top;
            
            const cellWidth = rect.width / 4;
            const cellHeight = rect.height / 4;
            
            const col = Math.floor(relativeX / cellWidth);
            const row = Math.floor(relativeY / cellHeight);
            
            if (col < 0 || col >= 4 || row < 0 || row >= 4) return null;
            
            const cellIndex = row * 4 + col;
            return cells[cellIndex] || null;
        }

        // Multitouch-aware touch handlers
        function handleTouchStart(e) {
            e.preventDefault();
            
            if (!audioInitialized || !synth) return;
            
            // Process all touches
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                // Add to global tracker
                globalActiveTouches.add(touchId);
                
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                
                if (cell) {
                    // Limit to maximum 6 dots
                    const MAX_DOTS = 6;
                    if (dotMixers.size >= MAX_DOTS) {
                        const oldestTouchId = dotMixers.keys().next().value;
                        if (oldestTouchId !== undefined) {
                            const oldestMixer = dotMixers.get(oldestTouchId);
                            if (oldestMixer) {
                                oldestMixer.startFade();
                            }
                            dotMixers.delete(oldestTouchId);
                            globalActiveTouches.delete(oldestTouchId);
                        }
                    }
                    
                    const cellNum = parseInt(cell.dataset.cell);
                    const mixer = new DotMixer(touchId, touch.clientX, touch.clientY, cellNum, synth);
                    dotMixers.set(touchId, mixer);
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            // Update global tracker with current browser touches
            const activeTouchIds = new Set();
            for (let i = 0; i < e.touches.length; i++) {
                const touchId = e.touches[i].identifier;
                activeTouchIds.add(touchId);
                globalActiveTouches.add(touchId); // Keep in global tracker
            }
            
            // Remove touches from global tracker if they're not in browser's list
            globalActiveTouches.forEach(touchId => {
                if (!activeTouchIds.has(touchId)) {
                    globalActiveTouches.delete(touchId);
                }
            });
            
            // Remove orphaned dots (touches that are no longer in the active list)
            dotMixers.forEach((mixer, touchId) => {
                if (!activeTouchIds.has(touchId) && !mixer.isFading) {
                    console.warn(`Orphaned touch detected in touchmove: ${touchId}`);
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(touchId);
                        globalActiveTouches.delete(touchId);
                    }, 700);
                }
            });
            
            // Update all active touches
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                const touchId = touch.identifier;
                
                const mixer = dotMixers.get(touchId);
                if (!mixer || mixer.isFading) continue;
                
                const cell = findCellFromCoordinates(touch.clientX, touch.clientY);
                mixer.updatePosition(touch.clientX, touch.clientY, cell);
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            // Process all touches
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const touchId = touch.identifier;
                
                // Remove from global tracker
                globalActiveTouches.delete(touchId);
                
                const mixer = dotMixers.get(touchId);
                if (mixer) {
                    mixer.startFade();
                    // Remove from map after fade completes
                    setTimeout(() => {
                        dotMixers.delete(touchId);
                    }, 700); // Match the 600ms fade + small buffer
                }
            }
        }

        // Mouse events for desktop (simulating touch)
        let mouseTouchId = null;
        
        document.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!audioInitialized || !synth) return;
            
            const cell = findCellFromCoordinates(e.clientX, e.clientY);
            if (!cell) return;
            
            // Limit to maximum 6 dots
            const MAX_DOTS = 6;
            if (dotMixers.size >= MAX_DOTS) {
                const oldestTouchId = dotMixers.keys().next().value;
                if (oldestTouchId !== undefined) {
                    const oldestMixer = dotMixers.get(oldestTouchId);
                    if (oldestMixer) {
                        oldestMixer.startFade();
                    }
                    dotMixers.delete(oldestTouchId);
                }
            }
            
            mouseTouchId = 'mouse_' + Date.now();
            const cellNum = parseInt(cell.dataset.cell);
            const mixer = new DotMixer(mouseTouchId, e.clientX, e.clientY, cellNum, synth);
            dotMixers.set(mouseTouchId, mixer);
        });
        
        document.addEventListener('mousemove', (e) => {
            if (e.buttons === 1 && mouseTouchId) {
                const mixer = dotMixers.get(mouseTouchId);
                if (mixer && !mixer.isFading) {
                    const cell = findCellFromCoordinates(e.clientX, e.clientY);
                    mixer.updatePosition(e.clientX, e.clientY, cell);
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (mouseTouchId) {
                const mixer = dotMixers.get(mouseTouchId);
                if (mixer) {
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(mouseTouchId);
                    }, 700); // Match the 600ms fade + small buffer
                }
                mouseTouchId = null;
            }
        });
        
        // Also handle mouseleave to catch cases where mouse leaves window
        document.addEventListener('mouseleave', () => {
            if (mouseTouchId) {
                const mixer = dotMixers.get(mouseTouchId);
                if (mixer) {
                    mixer.startFade();
                    setTimeout(() => {
                        dotMixers.delete(mouseTouchId);
                    }, 700);
                }
                mouseTouchId = null;
            }
        });

        // Add global touch event listeners
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Continuous update loop for mix percentages (optimized with requestAnimationFrame)
        let animationFrameId = null;
        function updateAllDotMixers() {
            dotMixers.forEach((mixer) => {
                if (!mixer.isFading) {
                    mixer.updateMixPercentages();
                }
            });
            
            // Continue animation loop
            animationFrameId = requestAnimationFrame(updateAllDotMixers);
        }
        
        // Start animation loop
        animationFrameId = requestAnimationFrame(updateAllDotMixers);
        
        // Periodic cleanup check - ensures all dots are properly tracked and removed
        // More aggressive cleanup with multiple strategies
        setInterval(() => {
            // Strategy 1: Force cleanup orphaned mixers
            forceCleanupOrphanedMixers();
            
            // Strategy 2: Original orphan detection
            // Check for any dots in DOM that aren't in our map
            const allDots = document.querySelectorAll('.touch-dot');
            const allDebugInfos = document.querySelectorAll('.dot-debug-info');
            
            // Find orphaned dots (dots in DOM but not tracked in dotMixers)
            // CRITICAL: When we find orphaned dots, we must also fade out their sounds
            allDots.forEach(dot => {
                let foundMixer = null;
                let foundTouchId = null;
                
                // First, try to find mixer using reverse lookup map
                const mixerFromMap = dotToMixerMap.get(dot);
                if (mixerFromMap) {
                    // Found mixer via reverse lookup
                    foundMixer = mixerFromMap;
                    // Find the touchId for this mixer
                    dotMixers.forEach((mixer, touchId) => {
                        if (mixer === mixerFromMap) {
                            foundTouchId = touchId;
                        }
                    });
                } else {
                    // Fallback: Search through all mixers directly
                    dotMixers.forEach((mixer, touchId) => {
                        if (mixer.dot === dot) {
                            foundMixer = mixer;
                            foundTouchId = touchId;
                        }
                    });
                }
                
                if (!foundMixer && dot.parentNode) {
                    // Truly orphaned dot - no mixer found at all
                    // This means the mixer was removed but dot wasn't cleaned up
                    // Remove it from DOM (sounds should have been cleaned up when mixer was removed)
                    dot.parentNode.removeChild(dot);
                    
                    // Also check for orphaned debug info that might match this dot's position
                    const dotRect = dot.getBoundingClientRect();
                    allDebugInfos.forEach(debugInfo => {
                        const debugRect = debugInfo.getBoundingClientRect();
                        // If debug info is near the dot's position, it's likely associated
                        const distance = Math.sqrt(
                            Math.pow(debugRect.left - dotRect.left, 2) + 
                            Math.pow(debugRect.top - dotRect.top, 2)
                        );
                        if (distance < 50 && debugInfo.parentNode) {
                            // Likely associated - remove it too
                            debugInfo.parentNode.removeChild(debugInfo);
                        }
                    });
                }
                // If foundMixer exists, it's properly tracked - don't interfere with active dragging
            });
            
            // Find orphaned debug infos
            allDebugInfos.forEach(debugInfo => {
                let found = false;
                dotMixers.forEach((mixer) => {
                    if (mixer.debugInfo === debugInfo) {
                        found = true;
                    }
                });
                if (!found && debugInfo.parentNode) {
                    // Orphaned debug info - remove it
                    debugInfo.parentNode.removeChild(debugInfo);
                }
            });
            
            // Also check if any mixers have dots that are missing from DOM
            // This catches cases where dots were removed but mixer still exists
            // Only check mixers that are already fading (don't interfere with active dragging)
            dotMixers.forEach((mixer, touchId) => {
                // Only check mixers that are already fading - don't trigger new fades
                if (mixer.isFading) {
                    // Check if fade timeout has passed (safety check)
                    const now = performance.now();
                    if (mixer.fadeStartTime && (now - mixer.fadeStartTime) > 1000) {
                        // Fade should have completed - force cleanup
                        mixer.cleanupCompletely();
                        dotMixers.delete(touchId);
                    }
                }
                // Don't check for missing dots on active mixers - let normal touch/mouse events handle cleanup
            });
        }, 500); // Check every 500ms (more frequent for better cleanup)

        // Cleanup on visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Cancel animation frame
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                dotMixers.forEach((mixer) => {
                    mixer.startFade();
                });
                dotMixers.clear();
            } else {
                // Restart animation loop when visible again
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(updateAllDotMixers);
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            dotMixers.forEach((mixer) => {
                mixer.startFade();
            });
        });
    </script>
</body>
</html>

